import { mockOpenConnection, closeConnection } from "trophy-rds-connection/index.mjs" 
import { 
    retrieveAllExercisesForUserId,
    retrieveLimitedExercisesForUserId } from "trophy-database-operations/ExercisesOperations.mjs";
import { compareUserId } from "trophy-common-utils/IdComparators.mjs";
import { translateExerciseSQLRowToJSON } from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";
import { prepareMultipleExerciseResponses } from "trophy-common-utils/PrepareAPIResponse.mjs";
import { ERROR } from "trophy-common-utils/Errors.mjs";

export const handler = async function (event, context) {


    try {

        console.time("time_check_validate");

        // Throw error if userId is undefined or null
        const userId = event.pathParameters.userId;
        if (userId === undefined || userId === null) {
            console.log("User ID data value:", userId);
            console.log("User ID data type:", typeof userId);
            throw new Error(`${ERROR.ERROR_INVALID_LAMBDA_PARAMETER_UNDEFINED_NULL}`);
        }

        console.timeEnd("time_check_validate");
        console.time("time_check_retrieve");

        // Open the Database connection
        let connection = await mockOpenConnection();

        // Call Retrieve Exercises function
        const exercisesRows = await retrieveLimitedExercisesForUserId(userId, connection);

        console.timeEnd("time_check_retrieve");

        // If no results were found, we can return a success response but no Exercise rows
        if (exercisesRows === null) {
            return {
                statusCode: 200,
                body: JSON.stringify({
                    userId: userId,
                    message: "No Exercises Found"
                })
            }
        } 
        // Else, we can translate each Exercise SQL Row into its own JSON object
        else {
            // Translate
            try {
                console.time("time_check_translate");
                const translatedExercises = exercisesRows.map(translateExerciseSQLRowToJSON);
                console.timeEnd("time_check_translate");

                console.time("time_check_compare");
                // Throw error if first userId !== exercise.userId
                if (!compareUserId(userId, translatedExercises[0].user_id)) {
                    console.log(`User with userId ${userId} does not have permission to view these Exercises. Likely due to mismatching user id's`);
                    throw new Error(`${ERROR.ERROR_RETRIEVE_EXERCISE_FAILED_PERMISSION_DENIED}`);
                }
                console.timeEnd("time_check_compare");

                // Prepare the Exercises for the response
                console.time("time_check_prepare");
                const response = await prepareMultipleExerciseResponses(translatedExercises, connection);
                console.timeEnd("time_check_prepare");

                // Return a 200 response and retrieved Exercises entry
                return {
                    statusCode: 200,
                    body: JSON.stringify({ 
                        exercises: response,
                        message: 'Function executed successfully' 
                    })
                };
            } catch (error) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({
                        userId: userId,
                        message: error.message
                    })
                };
            }

            //
        }

    } catch(error) {
        // Log function details (e.g. userId)
        console.log("Failed with userId", event.pathParameters.userId);

        // Log error details
        console.log(error.message);

        // Return body with error status code, error message, and any other details needed
        return {
            statusCode: 500,
            body: JSON.stringify({ 
                userId: event.pathParameters.userId,
                message: 'Internal server error' 
            })
        };
    } finally {
        // Close the DB connection
        await closeConnection();
    }

}