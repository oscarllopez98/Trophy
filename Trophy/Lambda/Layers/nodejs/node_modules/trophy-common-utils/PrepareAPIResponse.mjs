// import { 
//     retrieveExerciseAttribute,
//     retrieveDistanceAttribute,
//     retrieveTimeAttribute,
//     retrieveRepsAttribute, 
//     retrieveSetsAttribute,
//     retrieveWeightAttribute,
//     retrieveIntensityAttribute,
//     retrieveLevelAttribute 
// } from "trophy-database-operations/ExerciseAttributeOperations.mjs";
// import { 
//     translateExerciseAttributeSQLRowToJSON,
//     translateDistanceAttributeSQLRowToJSON,
//     translateTimeAttributeSQLRowToJSON,
//     translateSetsAttributeSQLRowToJSON,
//     translateRepsAttributeSQLRowToJSON,
//     translateWeightAttributeSQLRowToJSON,
//     translateIntensityAttributeSQLRowToJSON,
//     translateLevelAttributeSQLRowToJSON 
// } from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";
// import { translateExerciseTypeIDToUnit } from "trophy-exercise-data-processing/ExerciseTypeTranslator.mjs";

// /**
//  * Prepares an Exercise object for response, including translating attributes and exercise type.
//  * 
//  * @param {Object} exercise - The Exercise object to prepare.
//  * @param {Function} getConnectionV2 - Function for getting a connection object from the connection pool.
//  * @returns {Promise<Object>} A Promise that resolves to an object containing the prepared Exercise object and any errors.
//  * @throws {Error} If there is an error during attribute translation or if the Exercise type cannot be found.
//  */
// export const prepareExerciseResponse = async (exercise, getConnectionV2) => {
//     // If we have no exercise, throw new Error
//     if (!exercise) {
//         throw new Error("Exercise is null or undefined");
//     }

//     // Create the Exercise object that will be our in our Response
//     const exerciseObject = {
//         id: exercise.exercise_id,
//         name: exercise.exercise_name,
//         exerciseType: "other", // Default to 'other' until we translate the type we actually have
//         attributes: null, // Null until we translate the attributes we have
//         duration: null, // Null until we completely remove it
//         date: exercise.exercise_datetime_created,
//         notes: exercise.exercise_notes,
//     };

//     // Array to store any errors that occur during attribute retrieval
//     const attributeErrors = [];

//     // If the Exercise has attributes
//     if (exercise.exercise_attributes_id !== null) {
//         console.log("Exercise Atts...");
//         let label = "time_check_prepare_attributes" + exercise.exercise_attributes_id;

//         // Get a connection from the pool and retrieve + translate our Exercise Attribute row
//         console.log("Connection Attempt...");
//         console.log(exercise.exercise_attributes_id);
//         let conn = await getConnectionV2();
//         try {
//             console.log("Connection...");
//             const exerciseAttributesRow = await retrieveExerciseAttribute(exercise.exercise_attributes_id, conn);
//             const exerciseAttributes = translateExerciseAttributeSQLRowToJSON(exerciseAttributesRow);

//             // Keep a track of our attributes we have and a list to track Promises for async retrieval from the DB
//             const attributes = {};
//             const attributePromises = [];

//             console.log("Retrieved and Translated...");
//             // If we have a Distance attribute
//             if (exerciseAttributes.distance_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const distanceAttributeRow = await retrieveDistanceAttribute(exerciseAttributes.distance_attribute_id, connection);
//                             const distanceAttribute = await translateDistanceAttributeSQLRowToJSON(distanceAttributeRow, connection);
//                             attributes.distance = {
//                                 value: distanceAttribute.distance_attribute_value,
//                                 unit: distanceAttribute.distance_attribute_unit
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve distance attribute:', err);
//                             attributeErrors.push({ attribute: 'distance', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Time attribute
//             if (exerciseAttributes.time_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const timeAttributeRow = await retrieveTimeAttribute(exerciseAttributes.time_attribute_id, connection);
//                             const timeAttribute = await translateTimeAttributeSQLRowToJSON(timeAttributeRow, connection);
//                             attributes.time = {
//                                 value: timeAttribute.time_attribute_value,
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve time attribute:', err);
//                             attributeErrors.push({ attribute: 'time', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Sets attribute
//             if (exerciseAttributes.sets_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const setsAttributeRow = await retrieveSetsAttribute(exerciseAttributes.sets_attribute_id, connection);
//                             const setsAttribute = await translateSetsAttributeSQLRowToJSON(setsAttributeRow, connection);
//                             attributes.sets = {
//                                 value: setsAttribute.sets_attribute_value,
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve sets attribute:', err);
//                             attributeErrors.push({ attribute: 'sets', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Reps attribute
//             if (exerciseAttributes.reps_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const repsAttributeRow = await retrieveRepsAttribute(exerciseAttributes.reps_attribute_id, connection);
//                             const repsAttribute = await translateRepsAttributeSQLRowToJSON(repsAttributeRow, connection);
//                             attributes.reps = {
//                                 value: repsAttribute.reps_attribute_value,
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve reps attribute:', err);
//                             attributeErrors.push({ attribute: 'reps', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Weight attribute
//             if (exerciseAttributes.weight_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const weightAttributeRow = await retrieveWeightAttribute(exerciseAttributes.weight_attribute_id, connection);
//                             const weightAttribute = await translateWeightAttributeSQLRowToJSON(weightAttributeRow, connection);
//                             attributes.weight = {
//                                 value: weightAttribute.weight_attribute_value,
//                                 unit: weightAttribute.weight_attribute_unit
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve weight attribute:', err);
//                             attributeErrors.push({ attribute: 'weight', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Intensity attribute
//             if (exerciseAttributes.intensity_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const intensityAttributeRow = await retrieveIntensityAttribute(exerciseAttributes.intensity_attribute_id, connection);
//                             const intensityAttribute = await translateIntensityAttributeSQLRowToJSON(intensityAttributeRow, connection);
//                             attributes.intensity = {
//                                 value: intensityAttribute.intensity_attribute_value,
//                                 unit: intensityAttribute.intensity_attribute_unit
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve intensity attribute:', err);
//                             attributeErrors.push({ attribute: 'intensity', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }
//             // If we have a Level attribute
//             if (exerciseAttributes.level_attribute_id !== null) {
//                 attributePromises.push(
//                     (async () => {
//                         const connection = await getConnectionV2();
//                         try {
//                             const levelAttributeRow = await retrieveLevelAttribute(exerciseAttributes.level_attribute_id, connection);
//                             const levelAttribute = await translateLevelAttributeSQLRowToJSON(levelAttributeRow, connection);
//                             attributes.level = {
//                                 value: levelAttribute.level_attribute_value,
//                                 unit: levelAttribute.level_attribute_unit
//                             };
//                         } catch (err) {
//                             console.error('Failed to retrieve level attribute:', err);
//                             attributeErrors.push({ attribute: 'level', error: err });
//                         } finally {
//                             connection.release();
//                         }
//                     })()
//                 );
//             }

//             // Run all promises asynchronously and collect results
//             const results = await Promise.allSettled(attributePromises);
//             results.forEach(result => {
//                 if (result.status === 'rejected') {
//                     attributeErrors.push(result.reason);
//                 }
//             });

//             // Set out attributes to our Response object
//             exerciseObject.attributes = attributes;
//         } catch (err) {
//             console.error("Failed to retrieve exercise attributes:", err);
//         } finally {
//             conn.release();
//         }
//     }

//     // Get a connection from the pool and translate our Exercise type ID to the String interpretation
//     const connection = await getConnectionV2();
//     try {
//         const exerciseType = await translateExerciseTypeIDToUnit(exercise.exercise_type_id, connection);
//         if (exerciseType !== undefined && exerciseType !== null) {
//             exerciseObject.exerciseType = exerciseType;
//         } else {
//             throw new Error("Could not find Exercise Type");
//         }
//     } catch (err) {
//         console.error("Failed to retrieve exercise type:", err);
//     } finally {
//         connection.release();
//     }

//     // Log all attribute retrieval errors
//     if (attributeErrors.length > 0) {
//         console.error("Attribute retrieval errors:", attributeErrors);
//     }

//     // Return the response object with both the exerciseObject and attributeErrors
//     return {
//         exerciseObject,
//         attributeErrors
//     };
// };

// /**
//  * Prepares multiple Exercise objects for response by calling the prepareExerciseResponse function for each.
//  * 
//  * @param {Array<Object>} exercises - An array of Exercise objects to prepare.
//  * @param {Function} getConnectionV2 - The function to retrieve a database connection.
//  * @returns {Promise<Array<Object>>} A promise that resolves to an array of objects, each containing a prepared Exercise object and any errors.
//  */
// export const prepareMultipleExerciseResponses = async (exercises, getConnectionV2) => {
//     // Prepare each exercise and collect responses
//     const responses = await Promise.allSettled(exercises.map(exercise => prepareExerciseResponse(exercise, getConnectionV2)));
//     return responses;
// };













import {
    retrieveExerciseAttribute,
    retrieveDistanceAttribute,
    retrieveTimeAttribute,
    retrieveRepsAttribute,
    retrieveSetsAttribute,
    retrieveWeightAttribute,
    retrieveIntensityAttribute,
    retrieveLevelAttribute,
} from "trophy-database-operations/ExerciseAttributeOperations.mjs";

import {
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON,
} from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";

import { translateExerciseTypeIDToUnit } from "trophy-exercise-data-processing/ExerciseTypeTranslator.mjs";

/**
 * Prepares an Exercise object for response, including translating attributes and exercise type.
 * 
 * @param {Object} exercise - The Exercise object to prepare.
 * @param {Function} getConnectionV2 - Function for getting a connection object from the connection pool.
 * @returns {Promise<Object>} A Promise that resolves to an object containing the prepared Exercise object and any errors.
 * @throws {Error} If there is an error during attribute translation or if the Exercise type cannot be found.
 */
export const prepareExerciseResponse = async (exercise, getConnectionV2) => {
    if (!exercise) {
        throw new Error("Exercise is null or undefined");
    }

    const exerciseObject = {
        id: exercise.exercise_id,
        name: exercise.exercise_name,
        exerciseType: "other",
        attributes: null,
        duration: null,
        date: exercise.exercise_datetime_created,
        notes: exercise.exercise_notes,
    };

    const attributeErrors = [];

    let connection;
    try {
        console.log("Connection worked here 0");
        
        connection = await getConnectionV2();
        console.log("Connection worked here 1");

        if (exercise.exercise_attributes_id !== null) {
            const exerciseAttributesRow = await retrieveExerciseAttribute(exercise.exercise_attributes_id, connection);
            const exerciseAttributes = translateExerciseAttributeSQLRowToJSON(exerciseAttributesRow);

            const attributes = {};
            const attributePromises = [];

            if (exerciseAttributes.distance_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.distance_attribute_id,
                    retrieveDistanceAttribute,
                    translateDistanceAttributeSQLRowToJSON,
                    "distance",
                    connection
                ));
            }
            if (exerciseAttributes.time_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.time_attribute_id,
                    retrieveTimeAttribute,
                    translateTimeAttributeSQLRowToJSON,
                    "time",
                    connection
                ));
            }
            if (exerciseAttributes.sets_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.sets_attribute_id,
                    retrieveSetsAttribute,
                    translateSetsAttributeSQLRowToJSON,
                    "sets",
                    connection
                ));
            }
            if (exerciseAttributes.reps_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.reps_attribute_id,
                    retrieveRepsAttribute,
                    translateRepsAttributeSQLRowToJSON,
                    "reps",
                    connection
                ));
            }
            if (exerciseAttributes.weight_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.weight_attribute_id,
                    retrieveWeightAttribute,
                    translateWeightAttributeSQLRowToJSON,
                    "weight",
                    connection
                ));
            }
            if (exerciseAttributes.intensity_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.intensity_attribute_id,
                    retrieveIntensityAttribute,
                    translateIntensityAttributeSQLRowToJSON,
                    "intensity",
                    connection
                ));
            }
            if (exerciseAttributes.level_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.level_attribute_id,
                    retrieveLevelAttribute,
                    translateLevelAttributeSQLRowToJSON,
                    "level",
                    connection
                ));
            }
            console.log("Connection worked here 2");

            const results = await Promise.allSettled(attributePromises);
            console.log("Connection worked here 3");

            results.forEach(result => {
                if (result.status === "fulfilled") {
                    const { attribute, value, unit } = result.value;
                    attributes[attribute] = { value, unit };
                } else {
                    const { attribute, error } = result.reason;
                    console.error(`Failed to retrieve ${attribute} attribute:`, error);
                    attributeErrors.push({ attribute, error });
                }
            });

            console.log("Connection worked here 4");

            exerciseObject.attributes = attributes;
        }

        const exerciseType = await translateExerciseTypeIDToUnit(exercise.exercise_type_id, connection);
        if (exerciseType) {
            exerciseObject.exerciseType = exerciseType;
        } else {
            throw new Error("Exercise Type not found");
        }

        return { exerciseObject, attributeErrors };
    } catch (err) {
        console.error("Error preparing exercise response:", err);
        throw err;
    } finally {
        if (connection) {
            connection.release();
        }
    }
};

const retrieveAndTranslateAttribute = (attributeId, retrieveFunction, translateFunction, attributeName, connection) => {
    return new Promise(async (resolve, reject) => {
        try {
            const attributeRow = await retrieveFunction(attributeId, connection);
            const attribute = translateFunction(attributeRow, connection);
            resolve({
                attribute: attributeName,
                value: attribute[`${attributeName}_attribute_value`],
                unit: attribute[`${attributeName}_attribute_unit`]
            });
        } catch (error) {
            console.error(`Failed to retrieve ${attributeName} attribute:`, error);
            reject({ attribute: attributeName, error });
        }
    });
};


/**
 * Prepares multiple Exercise objects for response by calling the prepareExerciseResponse function for each.
 * 
 * @param {Array<Object>} exercises - An array of Exercise objects to prepare.
 * @param {Function} getConnectionV2 - The function to retrieve a database connection.
 * @returns {Promise<Array<Object>>} A promise that resolves to an array of objects, each containing a prepared Exercise object and any errors.
 */
export const prepareMultipleExerciseResponses = async (exercises, getConnectionV2) => {
    console.log("Preparing Multiple Exercise Responses"); // Ensure this line exists and triggers correctly
    
    try {
        const responses = await Promise.allSettled(exercises.map(exercise => prepareExerciseResponse(exercise, getConnectionV2)));
        
        console.log("Response Retrieved (true/false):", responses.every(response => response.status === 'fulfilled'));
        
        return responses.map(response => response.status === 'fulfilled' ? response.value : null);
    } catch (error) {
        console.error("Error preparing multiple exercise responses:", error.message);
        throw error;
    }
};
