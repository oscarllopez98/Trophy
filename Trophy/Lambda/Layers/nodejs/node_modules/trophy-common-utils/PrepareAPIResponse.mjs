import {
    retrieveExerciseAttribute,
    retrieveDistanceAttribute,
    retrieveRepsAttribute,
    retrieveSetsAttribute,
    retrieveWeightAttribute,
    retrieveIntensityAttribute,
    retrieveLevelAttribute,
    retrieveTimeAttribute
} from "trophy-database-operations/ExerciseAttributeOperations.mjs";

import {
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON
} from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";

import { translateExerciseTypeIDToUnit } from "trophy-exercise-data-processing/ExerciseTypeTranslator.mjs";

/**
 * Prepares a response object for a given exercise by retrieving and translating its attributes and type.
 *
 * @param {Object} exercise - The exercise object containing raw data from the database.
 * @param {Function} getConnectionV2 - A function that returns a database connection object.
 * @returns {Promise<Object>} - A promise that resolves to an object containing the prepared exercise response and any attribute errors.
 */
export const prepareExerciseResponse = async (exercise, getConnectionV2) => {
    if (!exercise) {
        throw new Error("Exercise is null or undefined");
    }

    const exerciseObject = {
        id: exercise.exercise_id,
        name: exercise.exercise_name,
        exerciseType: "other",
        attributes: null,
        duration: null,
        date: exercise.exercise_datetime_created,
        notes: exercise.exercise_notes,
    };

    const attributeErrors = [];

    let connection;
    try {
        connection = await getConnectionV2();

        if (exercise.exercise_attributes_id !== null) {
            const exerciseAttributesRow = await retrieveExerciseAttribute(exercise.exercise_attributes_id, connection);
            const exerciseAttributes = translateExerciseAttributeSQLRowToJSON(exerciseAttributesRow);
            const attributes = {};
            const attributePromises = [];

            if (exerciseAttributes.distance_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.distance_attribute_id,
                    retrieveDistanceAttribute,
                    translateDistanceAttributeSQLRowToJSON,
                    "distance",
                    connection
                ));
            }
            if (exerciseAttributes.reps_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.reps_attribute_id,
                    retrieveRepsAttribute,
                    translateRepsAttributeSQLRowToJSON,
                    "reps",
                    connection
                ));
            }
            if (exerciseAttributes.sets_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.sets_attribute_id,
                    retrieveSetsAttribute,
                    translateSetsAttributeSQLRowToJSON,
                    "sets",
                    connection
                ));
            }
            if (exerciseAttributes.weight_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.weight_attribute_id,
                    retrieveWeightAttribute,
                    translateWeightAttributeSQLRowToJSON,
                    "weight",
                    connection
                ));
            }
            if (exerciseAttributes.intensity_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.intensity_attribute_id,
                    retrieveIntensityAttribute,
                    translateIntensityAttributeSQLRowToJSON,
                    "intensity",
                    connection
                ));
            }
            if (exerciseAttributes.level_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.level_attribute_id,
                    retrieveLevelAttribute,
                    translateLevelAttributeSQLRowToJSON,
                    "level",
                    connection
                ));
            }
            if (exerciseAttributes.time_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.time_attribute_id,
                    retrieveTimeAttribute,
                    translateTimeAttributeSQLRowToJSON,
                    "time",
                    connection
                ));
            }

            const results = await Promise.allSettled(attributePromises);

            results.forEach(result => {
                if (result.status === "fulfilled") {
                    const { attribute, value, unit } = result.value;
                    attributes[attribute] = { value, unit };
                } else {
                    const { attribute, error } = result.reason;
                    console.error(`Failed to retrieve ${attribute} attribute:`, error);
                    attributeErrors.push({ attribute, error });
                }
            });

            exerciseObject.attributes = attributes;
        }

        const exerciseType = await translateExerciseTypeIDToUnit(exercise.exercise_type_id, connection);

        if (exerciseType) {
            exerciseObject.exerciseType = exerciseType;
        } else {
            throw new Error("Exercise Type not found");
        }

        return { exerciseObject, attributeErrors };
    } catch (err) {
        console.error("Error preparing exercise response:", err);
        throw err;
    } finally {
        if (connection) {
            connection.release();
        }
    }
};

/**
 * Retrieves and translates an attribute from a database, returning its value and unit.
 *
 * @param {string} attributeId - The ID of the attribute to retrieve.
 * @param {Function} retrieveFunction - A function that takes an attribute ID and a connection, and returns the raw attribute data.
 * @param {Function} translateFunction - A function that takes the raw attribute data and a connection, and translates it into the desired format.
 * @param {string} attributeName - The name of the attribute to retrieve and translate.
 * @param {Object} connection - The database connection object to use for the retrieval.
 * @returns {Promise<Object>} - A promise that resolves to an object containing the attribute name, value, and unit, or rejects with an error.
 */
const retrieveAndTranslateAttribute = async (attributeId, retrieveFunction, translateFunction, attributeName, connection) => {
    try {
        const attributeRow = await retrieveFunction(attributeId, connection);
        const attribute = await translateFunction(attributeRow, connection);

        return {
            attribute: attributeName,
            value: attribute[`${attributeName}_attribute_value`],
            unit: attribute[`${attributeName}_attribute_unit`]
        };
    } catch (error) {
        console.error(`Failed to retrieve ${attributeName} attribute with attribute id ${attributeId}:`, error);
        throw { attribute: attributeName, error };
    }
};

/**
 * Prepares multiple Exercise objects for response by calling the prepareExerciseResponse function for each.
 *
 * @param {Array<Object>} exercises - An array of Exercise objects to prepare.
 * @param {Function} getConnectionV2 - The function to retrieve a database connection.
 * @returns {Promise<Array<Object>>} - A promise that resolves to an array of objects, each containing a prepared Exercise object and any errors.
 */
export const prepareMultipleExerciseResponses = async (exercises, getConnectionV2) => {
    try {
        const responses = await Promise.allSettled(exercises.map(exercise => prepareExerciseResponse(exercise, getConnectionV2)));
        return responses.map(response => response.status === 'fulfilled' ? response.value : null);
    } catch (error) {
        console.error("Error preparing multiple exercise responses:", error.message);
        throw error;
    }
};
