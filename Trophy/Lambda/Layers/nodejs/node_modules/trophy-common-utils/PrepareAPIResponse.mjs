import {
    retrieveExerciseAttribute,
    retrieveDistanceAttribute,
    retrieveTimeAttribute,
    retrieveRepsAttribute,
    retrieveSetsAttribute,
    retrieveWeightAttribute,
    retrieveIntensityAttribute,
    retrieveLevelAttribute,
} from "trophy-database-operations/ExerciseAttributeOperations.mjs";

import {
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON,
} from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";

import { translateExerciseTypeIDToUnit } from "trophy-exercise-data-processing/ExerciseTypeTranslator.mjs";

/**
 * Prepares a response object for a given exercise by retrieving and translating its attributes and type.
 *
 * @param {Object} exercise - The exercise object containing raw data from the database.
 * @param {Function} getConnectionV2 - A function that returns a database connection object.
 * @returns {Promise<Object>} - A promise that resolves to an object containing the prepared exercise response and any attribute errors.
 *
 * The resolved object has the following structure:
 * {
 *   exerciseObject: {
 *     id: string,               // The ID of the exercise
 *     name: string,             // The name of the exercise
 *     exerciseType: string,     // The type of the exercise
 *     attributes: Object|null,  // The attributes of the exercise or null if no attributes are present
 *     duration: null,           // The duration of the exercise (currently always null)
 *     date: Date,               // The date when the exercise was created
 *     notes: string|null        // Any notes associated with the exercise
 *   },
 *   attributeErrors: Array      // An array of errors encountered while retrieving attributes
 * }
 *
 * If the exercise parameter is null or undefined, the function throws an error.
 *
 * Example usage:
 * prepareExerciseResponse(exerciseData, getConnectionV2)
 *   .then(response => {
 *     console.log('Exercise response prepared:', response);
 *   })
 *   .catch(error => {
 *     console.error('Failed to prepare exercise response:', error);
 *   });
 *
 * @throws {Error} - If the exercise is null or undefined, or if any error occurs during the preparation process.
 */
export const prepareExerciseResponse = async (exercise, getConnectionV2) => {
    if (!exercise) {
        throw new Error("Exercise is null or undefined");
    }

    // Instatiate Exercise object to have its details filled out later
    const exerciseObject = {
        id: exercise.exercise_id,
        name: exercise.exercise_name,
        exerciseType: "other",
        attributes: null,
        duration: null,
        date: exercise.exercise_datetime_created,
        notes: exercise.exercise_notes,
    };

    // Array for error tracking
    const attributeErrors = [];

    // Connection object used in async functions in the try-catch
    let connection;
    try {        
        // Get Connection
        connection = await getConnectionV2();

        // If Exercise Attributes is not null
        if (exercise.exercise_attributes_id !== null) {

            // Retrieve SQL Row
            const exerciseAttributesRow = await retrieveExerciseAttribute(exercise.exercise_attributes_id, connection);
            // Translate SQL Exercise Row to JSON format
            const exerciseAttributes = translateExerciseAttributeSQLRowToJSON(exerciseAttributesRow);

            // Object containing Attributes for the Exercise + Array of Promises for parallel processing
            const attributes = {};
            const attributePromises = [];

            // Now, we check which attributes exist for our Exercise

            // Distance
            if (exerciseAttributes.distance_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.distance_attribute_id,
                    retrieveDistanceAttribute,
                    translateDistanceAttributeSQLRowToJSON,
                    "distance",
                    connection
                ));
            }
            // Time
            if (exerciseAttributes.time_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.time_attribute_id,
                    retrieveTimeAttribute,
                    translateTimeAttributeSQLRowToJSON,
                    "time",
                    connection
                ));
            }
            // Sets
            if (exerciseAttributes.sets_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.sets_attribute_id,
                    retrieveSetsAttribute,
                    translateSetsAttributeSQLRowToJSON,
                    "sets",
                    connection
                ));
            }
            // Reps
            if (exerciseAttributes.reps_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.reps_attribute_id,
                    retrieveRepsAttribute,
                    translateRepsAttributeSQLRowToJSON,
                    "reps",
                    connection
                ));
            }
            // Weight
            if (exerciseAttributes.weight_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.weight_attribute_id,
                    retrieveWeightAttribute,
                    translateWeightAttributeSQLRowToJSON,
                    "weight",
                    connection
                ));
            }
            // Intensity
            if (exerciseAttributes.intensity_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.intensity_attribute_id,
                    retrieveIntensityAttribute,
                    translateIntensityAttributeSQLRowToJSON,
                    "intensity",
                    connection
                ));
            }
            // Level
            if (exerciseAttributes.level_attribute_id !== null) {
                attributePromises.push(retrieveAndTranslateAttribute(
                    exerciseAttributes.level_attribute_id,
                    retrieveLevelAttribute,
                    translateLevelAttributeSQLRowToJSON,
                    "level",
                    connection
                ));
            }

            // Containing results from Promises (could contain failures)
            const results = await Promise.allSettled(attributePromises);

            // Iterate through each Promise result
            results.forEach(result => {
                // If no checked error found, set appropriate property values
                if (result.status === "fulfilled") {
                    const { attribute, value, unit } = result.value;
                    attributes[attribute] = { value, unit };
                } 
                // Else, checked error found, log result + store error found
                else {
                    const { attribute, error } = result.reason;
                    console.error(`Failed to retrieve ${attribute} attribute:`, error);
                    attributeErrors.push({ attribute, error });
                }
            });

            // Update Exercise object with attribute values
            exerciseObject.attributes = attributes;
        }

        // Translate Exercise Type ID to the Unit equivalent (e.g. "1" -> "other")
        const exerciseType = await translateExerciseTypeIDToUnit(exercise.exercise_type_id, connection);

        // Check that we successfully got an exercise type
        if (exerciseType) {
            exerciseObject.exerciseType = exerciseType;
        } else {
            throw new Error("Exercise Type not found");
        }

        // Returning object containing built Exercise and Array of checked errors detected
        return { exerciseObject, attributeErrors };
    } catch (err) {
        console.error("Error preparing exercise response:", err);
        throw err;
    } finally {
        // Release pool connection
        if (connection) {
            connection.release();
        }
    }
};

/**
 * Retrieves and translates an attribute from a database, returning its value and unit.
 *
 * @param {string} attributeId - The ID of the attribute to retrieve.
 * @param {Function} retrieveFunction - A function that takes an attribute ID and a connection, and returns the raw attribute data.
 * @param {Function} translateFunction - A function that takes the raw attribute data and a connection, and translates it into the desired format.
 * @param {string} attributeName - The name of the attribute to retrieve and translate.
 * @param {Object} connection - The database connection object to use for the retrieval.
 * @returns {Promise<Object>} - A promise that resolves to an object containing the attribute name, value, and unit, or rejects with an error.
 *
 * The resolved object has the following structure:
 * {
 *   attribute: string, // The name of the attribute
 *   value: any,        // The value of the attribute
 *   unit: string       // The unit of the attribute
 * }
 *
 * If an error occurs during retrieval or translation, the promise is rejected with an object containing:
 * {
 *   attribute: string, // The id of the attribute
 *   attribute: string, // The name of the attribute
 *   error: Error       // The error that occurred
 * }
 *
 * Example usage:
 * retrieveAndTranslateAttribute('123', getAttributeFromDB, translateAttributeData, 'distance', dbConnection)
 *   .then(attribute => {
 *     console.log('Attribute retrieved:', attribute);
 *   })
 *   .catch(error => {
 *     console.error('Failed to retrieve attribute:', error);
 *   });
 */
const retrieveAndTranslateAttribute = (attributeId, retrieveFunction, translateFunction, attributeName, connection) => {
    return new Promise(async (resolve, reject) => {
        try {
            // Get Attribute 
            const attributeRow = await retrieveFunction(attributeId, connection);
            const attribute = translateFunction(attributeRow, connection);
            resolve({
                attribute: attributeName,
                value: attribute[`${attributeName}_attribute_value`],
                unit: attribute[`${attributeName}_attribute_unit`]
            });
        } catch (error) {
            console.error(`Failed to retrieve ${attributeName} attribute with attribute id ${attributeId}:`, error);
            reject({ attribute: attributeId, attributeName, error });
        }
    });
};


/**
 * Prepares multiple Exercise objects for response by calling the prepareExerciseResponse function for each.
 * 
 * @param {Array<Object>} exercises - An array of Exercise objects to prepare.
 * @param {Function} getConnectionV2 - The function to retrieve a database connection.
 * @returns {Promise<Array<Object>>} A promise that resolves to an array of objects, each containing a prepared Exercise object and any errors.
 */
export const prepareMultipleExerciseResponses = async (exercises, getConnectionV2) => {
    console.log("Preparing Multiple Exercise Responses"); // Ensure this line exists and triggers correctly
    
    try {
        const responses = await Promise.allSettled(exercises.map(exercise => prepareExerciseResponse(exercise, getConnectionV2)));
        
        console.log("Response Retrieved (true/false):", responses.every(response => response.status === 'fulfilled'));
        
        return responses.map(response => response.status === 'fulfilled' ? response.value : null);
    } catch (error) {
        console.error("Error preparing multiple exercise responses:", error.message);
        throw error;
    }
};
