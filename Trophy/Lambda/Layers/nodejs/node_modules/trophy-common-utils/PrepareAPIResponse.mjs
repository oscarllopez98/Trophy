import { 
    retrieveExerciseAttribute,
    retrieveDistanceAttribute,
    retrieveTimeAttribute,
    retrieveRepsAttribute, 
    retrieveSetsAttribute,
    retrieveWeightAttribute,
    retrieveIntensityAttribute,
    retrieveLevelAttribute } from "trophy-database-operations/ExerciseAttributeOperations.mjs";
import { 
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON } from "trophy-exercise-data-processing/SQLJSONTranslator.mjs";

import { translateExerciseTypeIDToUnit } from "trophy-exercise-data-processing/ExerciseTypeTranslator.mjs";

/**
 * Prepares an Exercise object for response, including translating attributes and exercise type.
 * 
 * @param {Object} exercise - The Exercise object to prepare.
 * @param {Function} getConnectionV2 - Function for getting a connection object from the connection pool.
 * @returns {Promise<Object>} A Promise that resolves to the prepared Exercise object for response.
 * @throws {Error} If there is an error during attribute translation or if the Exercise type cannot be found.
 */
export const prepareExerciseResponse = async (exercise, getConnectionV2) => {
    // If we have no exercise, throw new Error
    if (!exercise) {
        throw new Error("Exercise is null or undefined");
    }

    // Create the Exercise object that will be our in our Response
    const exerciseObject = {
        id: exercise.exercise_id,
        name: exercise.exercise_name,
        exerciseType: "other", // Default to 'other' until we translate the type we actually have
        attributes: null, // Null until we translate the attributes we have
        duration: null, // Null until we completely remove it
        date: exercise.exercise_datetime_created,
        notes: exercise.exercise_notes,
    };

    // If the Exercise has attributes
    if (exercise.exercise_attributes_id !== null) {
        let label = "time_check_prepare_attributes" + exercise.exercise_attributes_id;

        // Get a connection from the pool and retrieve + translate our Exercise Attribute row
        let conn = await getConnectionV2();
        const exerciseAttributesRow = await retrieveExerciseAttribute(exercise.exercise_attributes_id, conn);
        const exerciseAttributes = translateExerciseAttributeSQLRowToJSON(exerciseAttributesRow);
        
        // Keep a track of our attributes we have and a list to track Promises for async retrieval from the DB
        const attributes = {};
        const attributePromises = [];

        // If we have a Distance attribute
        if (exerciseAttributes.distance_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const distanceAttributeRow = await retrieveDistanceAttribute(exerciseAttributes.distance_attribute_id, connection);
                    const distanceAttribute = await translateDistanceAttributeSQLRowToJSON(distanceAttributeRow, connection);
                    attributes.distance = {
                        value: distanceAttribute.distance_attribute_value,
                        unit: distanceAttribute.distance_attribute_unit
                    };
                })()
            );
        }
        // If we have a Time attribute
        if (exerciseAttributes.time_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const timeAttributeRow = await retrieveTimeAttribute(exerciseAttributes.time_attribute_id, connection);
                    const timeAttribute = await translateTimeAttributeSQLRowToJSON(timeAttributeRow, connection);
                    attributes.time = {
                        value: timeAttribute.time_attribute_value,
                    };
                })()
            );
        }
        // If we have a Sets attribute
        if (exerciseAttributes.sets_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const setsAttributeRow = await retrieveSetsAttribute(exerciseAttributes.sets_attribute_id, connection);
                    const setsAttribute = await translateSetsAttributeSQLRowToJSON(setsAttributeRow, connection);
                    attributes.sets = {
                        value: setsAttribute.sets_attribute_value,
                    };
                })()
            );
        }
        // If we have a Reps attribute
        if (exerciseAttributes.reps_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const repsAttributeRow = await retrieveRepsAttribute(exerciseAttributes.reps_attribute_id, connection);
                    const repsAttribute = await translateRepsAttributeSQLRowToJSON(repsAttributeRow, connection);
                    attributes.reps = {
                        value: repsAttribute.reps_attribute_value,
                    };
                })()
            );
        }
        // If we have a Weight attribute
        if (exerciseAttributes.weight_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const weightAttributeRow = await retrieveWeightAttribute(exerciseAttributes.weight_attribute_id, connection);
                    const weightAttribute = await translateWeightAttributeSQLRowToJSON(weightAttributeRow, connection);
                    attributes.weight = {
                        value: weightAttribute.weight_attribute_value,
                        unit: weightAttribute.weight_attribute_unit
                    };
                })()
            );
        }
        // If we have a Intensity attribute
        if (exerciseAttributes.intensity_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const intensityAttributeRow = await retrieveIntensityAttribute(exerciseAttributes.intensity_attribute_id, connection);
                    const intensityAttribute = await translateIntensityAttributeSQLRowToJSON(intensityAttributeRow, connection);
                    attributes.intensity = {
                        value: intensityAttribute.intensity_attribute_value,
                        unit: intensityAttribute.intensity_attribute_unit
                    };
                })()
            );
        }
        // If we have a Level attribute
        if (exerciseAttributes.level_attribute_id !== null) {
            attributePromises.push(
                (async () => {
                    const connection = await getConnectionV2();
                    const levelAttributeRow = await retrieveLevelAttribute(exerciseAttributes.level_attribute_id, connection);
                    const levelAttribute = await translateLevelAttributeSQLRowToJSON(levelAttributeRow, connection);
                    attributes.level = {
                        value: levelAttribute.level_attribute_value,
                        unit: levelAttribute.level_attribute_unit
                    };
                })()
            );
        }

        // Run all promises asynchronously
        await Promise.all(attributePromises);

        // Set out attributes to our Response object
        exerciseObject.attributes = attributes;
    }

    // Get a connection from the pool and translate our Exercise type ID to the String interpretation
    const connection = await getConnectionV2();
    const exerciseType = await translateExerciseTypeIDToUnit(exercise.exercise_type_id, connection);
    if (exerciseType !== undefined && exerciseType !== null) {
        exerciseObject.exerciseType = exerciseType;
    } else {
        throw new Error("Could not find Exercise Type");
    }

    return exerciseObject;
}


/**
 * Prepares multiple Exercise objects for response by calling the prepareExerciseResponse function for each.
 * 
 * @param {Array<Object>} exercises - An array of Exercise objects to prepare.
 * @param {Function} getConnectionV2 - The function to retrieve a database connection.
 * @returns {Promise<Array<Object>>} A promise that resolves to an array of prepared Exercise objects ready for response.
 */
export const prepareMultipleExerciseResponses = async (exercises, getConnectionV2) => {
    const preparedExercisesPromises = exercises.map(exercise => prepareExerciseResponse(exercise, getConnectionV2));
    return Promise.all(preparedExercisesPromises);
};