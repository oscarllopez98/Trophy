import { v4 as uuidv4 } from 'uuid';

import { 
    EXERCISE_ATTRIBUTES_TABLE,
    DISTANCE_ATTRIBUTES_TABLE,
    TIME_ATTRIBUTES_TABLE,
    SETS_ATTRIBUTES_TABLE,
    REPS_ATTRIBUTES_TABLE,
    WEIGHT_ATTRIBUTES_TABLE,
    INTENSITY_ATTRIBUTES_TABLE,
    LEVEL_ATTRIBUTES_TABLE } from '../trophy-common-utils/DatabaseTables.mjs';
import { 
    EXERCISE_ATTRIBUTE_ID_COLUMN,
    USER_DEFINED_ATTRIBUTE_ID_COLUMN,
    DISTANCE_ATTRIBUTE_ID_COLUMN, DISTANCE_ATTRIBUTE_VALUE_COLUMN, DISTANCE_ATTRIBUTE_UNIT_ID_COLUMN,
    TIME_ATTRIBUTE_ID_COLUMN, TIME_ATTRIBUTE_SECONDS_VALUE_COLUMN,
    SETS_ATTRIBUTE_ID_COLUMN, SETS_ATTRIBUTE_VALUE_COLUMN,
    REPS_ATTRIBUTE_ID_COLUMN, REPS_ATTRIBUTE_VALUE_COLUMN,
    WEIGHT_ATTRIBUTE_ID_COLUMN, WEIGHT_ATTRIBUTE_VALUE_COLUMN, WEIGHT_ATTRIBUTE_UNIT_ID_COLUMN,
    INTENSITY_ATTRIBUTE_ID_COLUMN, INTENSITY_ATTRIBUTE_VALUE_ID_COLUMN,
    LEVEL_ATTRIBUTE_ID_COLUMN,LEVEL_ATTRIBUTE_VALUE_ID_COLUMN } from '../trophy-common-utils/DatabaseTableFields.mjs';

import { 
    validateExerciseAttributeJSONs,
    validateDistanceAttributeJSON,
    validateTimeAttributeJSON, 
    validateSetsAttributeJSON,
    validateRepsAttributeJSON,
    validateWeightAttributeJSON,
    validateIntensityAttributeJSON,
    validateLevelAttributeJSON }
    from '../trophy-attribute-helpers/AttributeJSONValidation.mjs'

import { setupUUIDToBinary16SQLStatement } from '../trophy-exercise-data-processing/UUIDBinaryTranslator.mjs'

import { 
    retrieveDistanceAttributeUnitID,
    retrieveWeightAttributeUnitID,
    retrieveIntensityAttributeValueID,
    retrieveLevelAttributeValueID
    } from '../trophy-database-operations/ExerciseAttributeUnitsOperations.mjs'

import {
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON
} from '../trophy-exercise-data-processing/SQLJSONTranslator.mjs'
import { ERROR } from 'trophy-common-utils/Errors.mjs';

/**
 * Creates a new exercise attribute entry in the database based on the provided exercise attribute JSON object.
 * 
 * @param {Object} exerciseAttributeJSON - The JSON object containing exercise attribute information.
 * @param {Object} connection - The database connection object.
 * @returns {string|boolean} Returns the UUID of the newly created exercise attribute entry if successful, otherwise returns false.
 */
export const createExerciseAttributeWithJSON = async (exerciseAttributeJSON, connection) => {
    //Verify we have defined parameters
    if (typeof exerciseAttributeJSON === 'undefined' || typeof connection === 'undefined') {
        console.log("Expected defined exerciseAttributeJSON. Actual exerciseAttributeJSON typeof ===", typeof exerciseAttributeJSON);
        console.log("Expected defined connection value. Actual connection typeof ===", typeof connection);
        throw new Error(ERROR.ERROR_PARAMETER_UNDEFINED);
    }
    if (validateExerciseAttributeJSONs(exerciseAttributeJSON)) {

        // Create an array to store promises
        const promises = [];

        // Define an object to store attribute IDs
        let exerciseAttributesObject = {
            user_defined_attribute_id: null // Set to null until this feature is implemented
        };

        // Check if each attribute exists in exerciseAttributeJSON and create the respective attribute
        if (exerciseAttributeJSON.distance) {
            promises.push(createDistanceAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.distance_attribute_id = id ? id : null;
            }));
        }
        if (exerciseAttributeJSON.time) {
            promises.push(createTimeAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.time_attribute_id = id ? id : null;
            }));
        }
        if (exerciseAttributeJSON.sets) {
            promises.push(createSetsAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.sets_attribute_id = id ? id : null;
            }));
        }
        if (exerciseAttributeJSON.reps) {
            promises.push(createRepsAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.reps_attribute_id = id ? id : null;
            }));
        }
        if (exerciseAttributeJSON.weight) {
            promises.push(createWeightAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.weight_attribute_id = id ? id: null;
            }));
        }
        if (exerciseAttributeJSON.intensity) {
            promises.push(createIntensityAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.intensity_attribute_id = id ? id : null;
            }));
        }
        if (exerciseAttributeJSON.level) {
            promises.push(createLevelAttribute(exerciseAttributeJSON, connection).then(id => {
                exerciseAttributesObject.level_attribute_id = id ? id : null;
            }));
        }

        // Execute the SQL update query and wait for all promises to resolve
        await Promise.all(promises);

        // Now exerciseAttributesObject object contains the IDs of attributes
        //console.log(exerciseAttributesObject);

        return await createExerciseAttribute(exerciseAttributesObject, connection);
    }
}


/**
 * Creates a new exercise attribute entry in the database.
 * 
 * @param {Object} exerciseAttributesObject - The exercise attribute object containing attribute IDs.
 * @param {Object} connection - The database connection object.
 * @returns {string|boolean} Returns the UUID of the newly created exercise attribute entry if successful, otherwise returns false.
 */
export const createExerciseAttribute = async (exerciseAttributesObject, connection) => {
    //Verify we have defined parameters
    if (typeof exerciseAttributesObject === 'undefined' || typeof connection === 'undefined') {
        console.log("Expected defined exerciseAttributeObject. Actual exerciseAttributeObject typeof ===", typeof exerciseAttributesObject);
        console.log("Expected defined connection value. Actual connection typeof ===", typeof connection);
        throw new Error(ERROR.ERROR_PARAMETER_UNDEFINED);
    }
    
    //If the distanceAttributeJSON is valid
    if (validateExerciseAttributeJSONs(exerciseAttributesObject)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();

            let userDefinedAttributeID = null; //Set to null until this feature is implemented
            let distanceAttributeID = exerciseAttributesObject.distance_attribute_id ? exerciseAttributesObject.distance_attribute_id : null;
            let timeAttributeID = exerciseAttributesObject.time_attribute_id ? exerciseAttributesObject.time_attribute_id : null;
            let setsAttributeID = exerciseAttributesObject.sets_attribute_id ? exerciseAttributesObject.sets_attribute_id : null;
            let repsAttributeID = exerciseAttributesObject.reps_attribute_id ? exerciseAttributesObject.reps_attribute_id : null;
            let weightAttributeID = exerciseAttributesObject.weight_attribute_id ? exerciseAttributesObject.weight_attribute_id : null;
            let intensityAttributeID = exerciseAttributesObject.intensity_attribute_id ? exerciseAttributesObject.intensity_attribute_id : null;
            let levelAttributeID = exerciseAttributesObject.level_attribute_id ? exerciseAttributesObject.level_attribute_id : null;

            const sql = `
            INSERT INTO ${EXERCISE_ATTRIBUTES_TABLE}
            (${EXERCISE_ATTRIBUTE_ID_COLUMN}, ${USER_DEFINED_ATTRIBUTE_ID_COLUMN}, ${DISTANCE_ATTRIBUTE_ID_COLUMN}, ${TIME_ATTRIBUTE_ID_COLUMN}, ${SETS_ATTRIBUTE_ID_COLUMN}, ${REPS_ATTRIBUTE_ID_COLUMN}, ${WEIGHT_ATTRIBUTE_ID_COLUMN}, ${INTENSITY_ATTRIBUTE_ID_COLUMN}, ${LEVEL_ATTRIBUTE_ID_COLUMN})
            VALUES (UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")), UNHEX(REPLACE(?, "-", "")));`;
        
            const args = [
                uuid, 
                userDefinedAttributeID ? uuid : null,
                distanceAttributeID ? distanceAttributeID : null,
                timeAttributeID ? timeAttributeID : null,
                setsAttributeID ? setsAttributeID : null,
                repsAttributeID ? repsAttributeID : null,
                weightAttributeID ? weightAttributeID : null,
                intensityAttributeID ? intensityAttributeID : null,
                levelAttributeID ? levelAttributeID : null
            ];

            // Log the SQL statement and its arguments
            // console.log('SQL:', sql);
            // console.log('Arguments:', args);

            const [rows, fields] = await connection.execute(sql, args);

            if (uuid) {
                console.log(`Expected Created Exercise Attribute with id exercise_attribute_id: ${uuid}.
                Listed are the Attribute id entries for the new row in the table:
                user_defined_attribute_id: ${userDefinedAttributeID}
                distance_attribute_id: ${distanceAttributeID}
                time_attribute_id: ${timeAttributeID}
                sets_attribute_id: ${setsAttributeID}
                reps_attribute_id: ${repsAttributeID}
                weight_attribute_id ${weightAttributeID}
                intensity_attribute_id: ${intensityAttributeID}
                level_attribute_id: ${levelAttributeID}`);
            }


            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
        
    } else {
        console.log("Error: Exercise Attribute List failed validation.")
        return false;
    }
}

/**
 * Retrieves an exercise attribute entry from the database by its ID.
 * 
 * @param {string} exerciseAttributeId - The UUID of the exercise attribute entry to retrieve.
 * @param {Object} connection - The database connection object.
 * @returns {Object|null} Returns the exercise attribute object if found, otherwise returns null.
 */
export const retrieveExerciseAttribute = async (exerciseAttributeId, connection) => {
    //Verify we have defined parameters
    if (typeof exerciseAttributeId === 'undefined' || typeof connection === 'undefined') {
        console.log("Expected defined exerciseAttributeId. Actual exerciseAttributeId typeof ===", typeof exerciseAttributeId);
        console.log("Expected defined connection value. Actual connection typeof ===", typeof connection);
        throw new Error(ERROR.ERROR_PARAMETER_UNDEFINED);
    }
    try {

        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ EXERCISE_ATTRIBUTES_TABLE } 
            WHERE  ${ EXERCISE_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [exerciseAttributeId]);
        
        //Return if any rows were found
        // if (rows.length > 0) console.log(`Retrieved Exercise Attribute RAW SQL with exerciseAttributeId ${exerciseAttributeId}:`,rows[0]);
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing exercise attribute entry in the database.
 * 
 * @param {string} currentExerciseAttributeId - The UUID of the exercise attribute entry to update.
 * @param {string} newExerciseAttributeId - The new UUID for the exercise attribute entry.
 * @param {Object} newExerciseAttributeObject - The updated exercise attribute object.
 * @param {Object} connection - The database connection object.
 * @returns {Object|null} Returns the updated exercise attribute object if successful, otherwise returns null.
 */
export const updateExerciseAttribute = async (currentExerciseAttributeId, newExerciseAttributeId, newExerciseAttributeObject, connection) => {
    //Verify we have defined parameters
    if (typeof currentExerciseAttributeId === 'undefined' || typeof newExerciseAttributeId === 'undefined' || typeof newExerciseAttributeObject === 'undefined' || typeof connection === 'undefined') {
        console.log("Expected defined currentExerciseAttributeId. Actual currentExerciseAttributeId typeof ===", typeof currentExerciseAttributeId);
        console.log("Expected defined newExerciseAttributeId. Actual newExerciseAttributeId typeof ===", typeof newExerciseAttributeId);
        console.log("Expected defined newExerciseAttributeObject. Actual newExerciseAttributeObject typeof ===", typeof newExerciseAttributeObject);
        console.log("Expected defined connection value. Actual connection typeof ===", typeof connection);
        throw new Error(ERROR.ERROR_PARAMETER_UNDEFINED);
    }
    try {
        // Validate the input JSON object
        if (validateExerciseAttributeJSONs(newExerciseAttributeObject)) {

            //Retrieve the Exercise Attribute from the database and format into JSON

            const retrievedExerciseAttributeRow = await retrieveExerciseAttribute(currentExerciseAttributeId, connection);
            const retrievedExerciseAttribute = translateExerciseAttributeSQLRowToJSON(retrievedExerciseAttributeRow, connection);

            console.log(`Updating Exercise Attribute with exercise_attribute_id: ${retrievedExerciseAttribute.exercise_attribute_id}`);

            // Define the IDs that will be stored in the ExerciseAttribute entry
            let currentUserDefinedAttributeID = null; //Set to null until this feature is implemented
            let currentDistanceAttributeID = retrievedExerciseAttribute.distance_attribute_id;
            let currentTimeAttributeID = retrievedExerciseAttribute.time_attribute_id;
            let currentSetsAttributeID = retrievedExerciseAttribute.sets_attribute_id;
            let currentRepsAttributeID = retrievedExerciseAttribute.reps_attribute_id;
            let currentWeightAttributeID = retrievedExerciseAttribute.weight_attribute_id;
            let currentIntensityAttributeID = retrievedExerciseAttribute.intensity_attribute_id;
            let currentLevelAttributeID = retrievedExerciseAttribute.level_attribute_id;

            // Define the IDs that will be stored in the ExerciseAttribute entry
            // If we already have an ID, we can use the existing ID, else we need to create an entry
            
            let updatedUserDefinedAttributeID = null; //Set to null until this feature is implemented
      
            let updatedDistanceAttributeID = currentDistanceAttributeID;
            let updatedTimeAttributeID = currentTimeAttributeID;
            let updatedSetsAttributeID = currentSetsAttributeID;
            let updatedRepsAttributeID = currentRepsAttributeID;
            let updatedWeightAttributeID = currentWeightAttributeID;
            let updatedIntensityAttributeID = currentIntensityAttributeID;
            let updatedLevelAttributeID = currentLevelAttributeID;

            // If we want a Distance Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.distance && !currentDistanceAttributeID) {
                updatedDistanceAttributeID = await createDistanceAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Time Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.time && !currentTimeAttributeID) {
                updatedTimeAttributeID = await createTimeAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Sets Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.sets && !currentSetsAttributeID) {
                updatedSetsAttributeID = await createSetsAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Reps Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.reps && !currentRepsAttributeID) {
                updatedRepsAttributeID = await createRepsAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Weight Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.weight && !currentWeightAttributeID) {
                updatedWeightAttributeID = await createWeightAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Intensity Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.intensity && !currentIntensityAttributeID) {
                updatedIntensityAttributeID = await createIntensityAttribute(newExerciseAttributeObject, connection);
            }
            // If we want a Level Attribute ID entry and do not have a non-null one, create one
            if (newExerciseAttributeObject.level && !currentLevelAttributeID) {
                updatedLevelAttributeID = await createLevelAttribute(newExerciseAttributeObject, connection);
            }

            // We have now created attribute entries for attributes where they did not exist and we need them to exist

            // Create an array to store promises
            const promises = [];

            // Create an object to store the return values of delete functions
            const deleteResults = {};

            // Now, we need to delete the entries that we have but do not want
            if (!newExerciseAttributeObject.distance && currentDistanceAttributeID) {
                promises.push(deleteDistanceAttribute(currentDistanceAttributeID, connection)
                    .then(result => deleteResults[currentDistanceAttributeID] = result));
                updatedDistanceAttributeID = null;
            }
            if (!newExerciseAttributeObject.time && currentTimeAttributeID) {
                promises.push(deleteTimeAttribute(currentTimeAttributeID, connection)
                    .then(result => deleteResults[currentTimeAttributeID] = result));
                    updatedTimeAttributeID = null;
            }
            if (!newExerciseAttributeObject.sets && currentSetsAttributeID) {
                promises.push(deleteSetsAttribute(currentSetsAttributeID, connection)
                    .then(result => deleteResults[currentSetsAttributeID] = result));
                    updatedSetsAttributeID = null;
            }
            if (!newExerciseAttributeObject.reps && currentRepsAttributeID) {
                promises.push(deleteRepsAttribute(currentRepsAttributeID, connection)
                    .then(result => deleteResults[currentRepsAttributeID] = result));
                    updatedRepsAttributeID = null;
            }
            if (!newExerciseAttributeObject.weight && currentWeightAttributeID) {
                promises.push(deleteWeightAttribute(currentWeightAttributeID, connection)
                    .then(result => deleteResults[currentWeightAttributeID] = result));
                    updatedWeightAttributeID = null;
            }
            if (!newExerciseAttributeObject.intensity && currentIntensityAttributeID) {
                promises.push(deleteIntensityAttribute(currentIntensityAttributeID, connection)
                    .then(result => deleteResults[currentIntensityAttributeID] = result));
                    updatedIntensityAttributeID = null;
            }
            if (!newExerciseAttributeObject.level && currentLevelAttributeID) {
                promises.push(deleteLevelAttribute(currentLevelAttributeID, connection)
                    .then(result => deleteResults[currentLevelAttributeID] = result));
                    updatedLevelAttributeID = null;
            }

            // We have now scheduled attributes to be deleted that we do not need anymore


            // Create an object to store the return values of update functions
            const updateResults = {};

            // Lastly, we need to update the entries where we have an entry and want to update the existing value
            if (newExerciseAttributeObject.distance && currentDistanceAttributeID) {
                promises.push(updateDistanceAttribute(currentDistanceAttributeID, currentDistanceAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentDistanceAttributeID] = translateDistanceAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.time && currentTimeAttributeID) {
                promises.push(updateTimeAttribute(currentTimeAttributeID, currentTimeAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentTimeAttributeID] = translateTimeAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.sets && currentSetsAttributeID) {
                promises.push(updateSetsAttribute(currentSetsAttributeID, currentSetsAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentSetsAttributeID] = translateSetsAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.reps && currentRepsAttributeID) {
                promises.push(updateRepsAttribute(currentRepsAttributeID, currentRepsAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentRepsAttributeID] = translateRepsAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.weight && currentWeightAttributeID) {
                promises.push(updateWeightAttribute(currentWeightAttributeID, currentWeightAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentWeightAttributeID] = translateWeightAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.intensity && currentIntensityAttributeID) {
                promises.push(updateIntensityAttribute(currentIntensityAttributeID, currentIntensityAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentIntensityAttributeID] = translateIntensityAttributeSQLRowToJSON(result, connection)));
            }
            if (newExerciseAttributeObject.level && currentLevelAttributeID) {
                promises.push(updateLevelAttribute(currentLevelAttributeID, currentLevelAttributeID, newExerciseAttributeObject, connection)
                    .then(result => updateResults[currentLevelAttributeID] = translateLevelAttributeSQLRowToJSON(result, connection)));
            }

            // Execute the SQL update query and wait for all promises to resolve
            await Promise.all(promises);

            // Log the updateResults and deleteResults object
            console.log("Deleted the following Attributes since they are no longer needed in our update:", deleteResults);
            console.log("Updated Exercise Attribute:", updateResults);

            const [rows, fields] = await connection.execute(`
                UPDATE ${EXERCISE_ATTRIBUTES_TABLE}
                SET ${USER_DEFINED_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${DISTANCE_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${TIME_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${SETS_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${REPS_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${WEIGHT_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${INTENSITY_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", "")), ${LEVEL_ATTRIBUTE_ID_COLUMN}=UNHEX(REPLACE(?, "-", ""))
                WHERE ${EXERCISE_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""))
                ;`
                ,
                [updatedUserDefinedAttributeID, updatedDistanceAttributeID, updatedTimeAttributeID, updatedSetsAttributeID, updatedRepsAttributeID, updatedWeightAttributeID, updatedIntensityAttributeID, updatedLevelAttributeID, currentExerciseAttributeId]
            );

            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveExerciseAttribute(currentExerciseAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input list is invalid
            console.log("Error: Exercise Attribute list failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an exercise attribute entry from the database by its ID.
 * 
 * @param {string} exerciseAttributeId - The UUID of the exercise attribute entry to delete.
 * @param {Object} connection - The database connection object.
 * @returns {boolean} Returns true if the exercise attribute entry was successfully deleted, otherwise returns false.
 */
export const deleteExerciseAttribute = async (exerciseAttributeId, connection) => {
    //Verify we have defined parameters
    if (typeof exerciseAttributeId === 'undefined' || typeof connection === 'undefined') {
        console.log("Expected defined exerciseAttributeId. Actual exerciseAttributeId typeof ===", typeof exerciseAttributeId);
        console.log("Expected defined connection. Actual connection typeof ===", typeof connection);
        throw new Error(ERROR.ERROR_PARAMETER_UNDEFINED);
    }
    try {

        //Retrieve the Exercise Attribute from the database and format into JSON
        const retrievedExerciseAttributeRow = await retrieveExerciseAttribute(exerciseAttributeId, connection);
        const retrievedExerciseAttribute = await translateExerciseAttributeSQLRowToJSON(retrievedExerciseAttributeRow, connection);

        // Create an array to store promises
        const promises = [];

        // Create an object to store the return values of delete functions
        const deleteResults = {};

        //Delete all attributes through referencing their IDs
        if (retrievedExerciseAttribute[`${USER_DEFINED_ATTRIBUTE_ID_COLUMN}`]) {
            //Do nothing because no implementation
        }
        if (retrievedExerciseAttribute[`${DISTANCE_ATTRIBUTE_ID_COLUMN}`]) {
            const distanceAttributeID = retrievedExerciseAttribute[`${DISTANCE_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Distance Attribute with ID", distanceAttributeID);

            promises
                .push(
                    deleteDistanceAttribute(distanceAttributeID, connection)
                .then(result => deleteResults[distanceAttributeID] = result));  
        }
        if (retrievedExerciseAttribute[`${TIME_ATTRIBUTE_ID_COLUMN}`]) {
            const timeAttributeID = retrievedExerciseAttribute[`${TIME_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Time Attribute with ID", timeAttributeID);

            promises
                .push(
                    deleteTimeAttribute(timeAttributeID, connection)
                .then(result => deleteResults[timeAttributeID] = result)); 
        }
        if (retrievedExerciseAttribute[`${SETS_ATTRIBUTE_ID_COLUMN}`]) {
            const setsAttributeID = retrievedExerciseAttribute[`${SETS_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Sets Attribute with ID", setsAttributeID);

            promises
                .push(
                    deleteSetsAttribute(setsAttributeID, connection)
                .then(result => deleteResults[setsAttributeID] = result)); 
        }
        if (retrievedExerciseAttribute[`${REPS_ATTRIBUTE_ID_COLUMN}`]) {
            const repsAttributeID = retrievedExerciseAttribute[`${REPS_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Reps Attribute with ID", repsAttributeID);

            promises
                .push(
                    deleteRepsAttribute(repsAttributeID, connection)
                .then(result => deleteResults[repsAttributeID] = result)); 
        }
        if (retrievedExerciseAttribute[`${WEIGHT_ATTRIBUTE_ID_COLUMN}`]) {
            const weightAttributeID = retrievedExerciseAttribute[`${WEIGHT_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Weight Attribute with ID", weightAttributeID);

            promises
                .push(
                    deleteWeightAttribute(weightAttributeID, connection)
                .then(result => deleteResults[weightAttributeID] = result)); 
        }
        if (retrievedExerciseAttribute[`${INTENSITY_ATTRIBUTE_ID_COLUMN}`]) {
            const intensityAttributeID = retrievedExerciseAttribute[`${INTENSITY_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Intensity Attribute with ID", intensityAttributeID);

            promises
                .push(
                    deleteIntensityAttribute(intensityAttributeID, connection)
                .then(result => deleteResults[intensityAttributeID] = result)); 
        }
        if (retrievedExerciseAttribute[`${LEVEL_ATTRIBUTE_ID_COLUMN}`]) {
            const levelAttributeID = retrievedExerciseAttribute[`${LEVEL_ATTRIBUTE_ID_COLUMN}`];
            console.log("Attempting to Delete Level Attribute with ID", levelAttributeID);

            promises
                .push(
                    deleteLevelAttribute(levelAttributeID, connection)
                .then(result => deleteResults[levelAttributeID] = result)); 
        }

        // Execute the SQL update query and wait for all promises to resolve
        await Promise.all(promises);

        // Log the updateResults object
        console.log("Deleted Attributes:", deleteResults);

        //Finally, delete the overall exercise_attribute
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${EXERCISE_ATTRIBUTES_TABLE}
            WHERE ${EXERCISE_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [exerciseAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        if (result.affectedRows > 0) console.log(`Successfully Deleted Exercise Attribute with exercise_attribute_id:`, exerciseAttributeId);
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new distance attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * retrieves the correct distance attribute unit ID, and executes
 * an SQL INSERT query to create the new distance attribute entry.
 * 
 * @param {Object} distanceAttributeJSON - The JSON object representing the distance attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created distance attribute entry if successful,
 *                            otherwise returns false.
 */
export const createDistanceAttribute = async (distanceAttributeJSON, connection) => {
    //If the distanceAttributeJSON is valid
    if (validateDistanceAttributeJSON(distanceAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Retrieve the correct distance attribute unit id
            const distanceAttributeUnitId = await retrieveDistanceAttributeUnitID(distanceAttributeJSON.distance.unit, connection);

            // Execute SQL statement to create a new distance_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ DISTANCE_ATTRIBUTES_TABLE } (${ DISTANCE_ATTRIBUTE_ID_COLUMN }, ${ DISTANCE_ATTRIBUTE_VALUE_COLUMN }, ${ DISTANCE_ATTRIBUTE_UNIT_ID_COLUMN }) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(distanceAttributeJSON.distance.value)}, ${(distanceAttributeUnitId)} );
                `, [uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }


    } else {
        console.log("Error: Distance Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves a distance attribute entry from the database based on the provided ID.
 * Executes an SQL SELECT query to retrieve the row with matching ID and returns it.
 * 
 * @param {string} distanceAttributeId - The ID of the distance attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved distance attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveDistanceAttribute = async (distanceAttributeId, connection) => {
    try {

        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ DISTANCE_ATTRIBUTES_TABLE } 
            WHERE  ${ DISTANCE_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [distanceAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing distance attribute entry in the database.
 * Validates the input JSON object, retrieves the correct distance attribute unit ID,
 * executes an SQL UPDATE query to update the specified distance attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentDistanceAttributeId - The current ID of the distance attribute to be updated.
 * @param {string} newDistanceAttributeId - The new ID for the distance attribute after updating.
 * @param {Object} distanceAttributeJSON - The JSON object representing the new values for the distance attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated distance attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateDistanceAttribute = async (currentDistanceAttributeId, newDistanceAttributeId, distanceAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateDistanceAttributeJSON(distanceAttributeJSON)) {

            // Retrieve the correct distance attribute unit id
            const distanceAttributeUnitId = await retrieveDistanceAttributeUnitID(distanceAttributeJSON.distance.unit, connection);

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${DISTANCE_ATTRIBUTES_TABLE} 
                SET
                    ${DISTANCE_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${DISTANCE_ATTRIBUTE_VALUE_COLUMN} = ?,
                    ${DISTANCE_ATTRIBUTE_UNIT_ID_COLUMN} = ?
                WHERE ${DISTANCE_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newDistanceAttributeId, distanceAttributeJSON.distance.value, distanceAttributeUnitId, currentDistanceAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveDistanceAttribute(newDistanceAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Distance Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing distance attribute entry from the database.
 * Executes an SQL DELETE query to remove the distance attribute entry with the specified ID.
 * 
 * @param {string} distanceAttributeId - The ID of the distance attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteDistanceAttribute = async (distanceAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${DISTANCE_ATTRIBUTES_TABLE}
            WHERE ${DISTANCE_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [distanceAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new time attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * and executes an SQL INSERT query to create the new time attribute entry.
 * 
 * @param {Object} timeAttributeJSON - The JSON object representing the time attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created time attribute entry if successful,
 *                            otherwise returns false.
 */
export const createTimeAttribute = async (timeAttributeJSON, connection) => {
    //If the timeAttributeJSON is valid
    if (validateTimeAttributeJSON(timeAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Execute SQL statement to create a new time_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ TIME_ATTRIBUTES_TABLE } (${ TIME_ATTRIBUTE_ID_COLUMN }, ${ TIME_ATTRIBUTE_SECONDS_VALUE_COLUMN } ) 
                VALUES (UNHEX(REPLACE(?, "-", "")), ${(timeAttributeJSON.time.value)} );
                `, [uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
    } else {
        console.log("Error: Time Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing time attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} timeAttributeId - The ID of the time attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved time attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */

export const retrieveTimeAttribute = async (timeAttributeId, connection) => {
    try {
        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ TIME_ATTRIBUTES_TABLE } 
            WHERE  ${ TIME_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [timeAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing time attribute entry in the database.
 * Validates the input JSON object, executes an SQL UPDATE query to update the specified time attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentTimeAttributeId - The current ID of the time attribute to be updated.
 * @param {string} newTimeAttributeId - The new ID for the time attribute after updating.
 * @param {Object} timeAttributeJSON - The JSON object representing the new values for the time attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated time attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateTimeAttribute = async (currentTimeAttributeId, newTimeAttributeId, timeAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateTimeAttributeJSON(timeAttributeJSON)) {

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${TIME_ATTRIBUTES_TABLE} 
                SET
                    ${TIME_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${TIME_ATTRIBUTE_SECONDS_VALUE_COLUMN} = ?
                WHERE ${TIME_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newTimeAttributeId, timeAttributeJSON.time.value, currentTimeAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveTimeAttribute(newTimeAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Time Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing time attribute entry from the database.
 * Executes an SQL DELETE query to remove the time attribute entry with the specified ID.
 * 
 * @param {string} timeAttributeId - The ID of the time attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteTimeAttribute = async (timeAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${TIME_ATTRIBUTES_TABLE}
            WHERE ${TIME_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [timeAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new sets attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * and executes an SQL INSERT query to create the new sets attribute entry.
 * 
 * @param {Object} setsAttributeJSON - The JSON object representing the sets attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created sets attribute entry if successful,
 *                            otherwise returns false.
 */
export const createSetsAttribute = async (setsAttributeJSON, connection) => {
    //If the setsAttributeJSON is valid
    if (validateSetsAttributeJSON(setsAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Execute SQL statement to create a new time_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ SETS_ATTRIBUTES_TABLE } (${ SETS_ATTRIBUTE_ID_COLUMN }, ${ SETS_ATTRIBUTE_VALUE_COLUMN } ) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(setsAttributeJSON.sets.value)} );
                `,[uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
    } else {
        console.log("Error: Sets Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing sets attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} setsAttributeId - The ID of the sets attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved sets attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveSetsAttribute = async (setsAttributeId, connection) => {
    try {
        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ SETS_ATTRIBUTES_TABLE } 
            WHERE  ${ SETS_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [setsAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing sets attribute entry in the database.
 * Validates the input JSON object, executes an SQL UPDATE query to update the specified sets attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentSetsAttributeId - The current ID of the sets attribute to be updated.
 * @param {string} newSetsAttributeId - The new ID for the sets attribute after updating.
 * @param {Object} setsAttributeJSON - The JSON object representing the new values for the sets attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated sets attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateSetsAttribute = async (currentSetsAttributeId, newSetsAttributeId, setsAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateSetsAttributeJSON(setsAttributeJSON)) {

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${SETS_ATTRIBUTES_TABLE} 
                SET
                    ${SETS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${SETS_ATTRIBUTE_VALUE_COLUMN} = ?
                WHERE ${SETS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newSetsAttributeId, setsAttributeJSON.sets.value, currentSetsAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveSetsAttribute(newSetsAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Sets Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing sets attribute entry from the database.
 * Executes an SQL DELETE query to remove the sets attribute entry with the specified ID.
 * 
 * @param {string} setsAttributeId - The ID of the sets attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteSetsAttribute = async (setsAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${SETS_ATTRIBUTES_TABLE}
            WHERE ${SETS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [setsAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new reps attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * and executes an SQL INSERT query to create the new reps attribute entry.
 * 
 * @param {Object} repsAttributeJSON - The JSON object representing the reps attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created reps attribute entry if successful,
 *                            otherwise returns false.
 */
export const createRepsAttribute = async (repsAttributeJSON, connection) => {
    //If the setsAttributeJSON is valid
    if (validateRepsAttributeJSON(repsAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Execute SQL statement to create a new time_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ REPS_ATTRIBUTES_TABLE } (${ REPS_ATTRIBUTE_ID_COLUMN }, ${ REPS_ATTRIBUTE_VALUE_COLUMN } ) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(repsAttributeJSON.reps.value)} );
                `,[uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
    } else {
        console.log("Error: Reps Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing reps attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} repsAttributeId - The ID of the reps attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved reps attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveRepsAttribute = async (repsAttributeId, connection) => {
    try {
        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ REPS_ATTRIBUTES_TABLE } 
            WHERE  ${ REPS_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [repsAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing reps attribute entry in the database.
 * Validates the input JSON object, executes an SQL UPDATE query to update the specified reps attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentRepsAttributeId - The current ID of the reps attribute to be updated.
 * @param {string} newRepsAttributeId - The new ID for the reps attribute after updating.
 * @param {Object} repsAttributeJSON - The JSON object representing the new values for the reps attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated reps attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateRepsAttribute = async (currentRepsAttributeId, newRepsAttributeId, repsAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateRepsAttributeJSON(repsAttributeJSON)) {

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${REPS_ATTRIBUTES_TABLE} 
                SET
                    ${REPS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${REPS_ATTRIBUTE_VALUE_COLUMN} = ?
                WHERE ${REPS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newRepsAttributeId, repsAttributeJSON.reps.value, currentRepsAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveRepsAttribute(newRepsAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Reps Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing reps attribute entry from the database.
 * Executes an SQL DELETE query to remove the reps attribute entry with the specified ID.
 * 
 * @param {string} repsAttributeId - The ID of the reps attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteRepsAttribute = async (repsAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${REPS_ATTRIBUTES_TABLE}
            WHERE ${REPS_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [repsAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new weight attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * retrieves the correct weight attribute unit ID, and executes an SQL INSERT query.
 * 
 * @param {Object} weightAttributeJSON - The JSON object representing the weight attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created weight attribute entry if successful,
 *                            otherwise returns false.
 */
export const createWeightAttribute = async (weightAttributeJSON, connection) => {
    //If the distanceAttributeJSON is valid
    if (validateWeightAttributeJSON(weightAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Retrieve the correct weight attribute unit id
            const weightAttributeUnitId = await retrieveWeightAttributeUnitID(weightAttributeJSON.weight.unit, connection);

            // Execute SQL statement to create a new weight_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ WEIGHT_ATTRIBUTES_TABLE } (${ WEIGHT_ATTRIBUTE_ID_COLUMN }, ${ WEIGHT_ATTRIBUTE_VALUE_COLUMN }, ${ WEIGHT_ATTRIBUTE_UNIT_ID_COLUMN }) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(weightAttributeJSON.weight.value)}, ${(weightAttributeUnitId)} );
                `,[uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }

    } else {
        console.log("Error: Distance Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing weight attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} weightAttributeId - The ID of the weight attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved weight attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveWeightAttribute = async (weightAttributeId, connection) => {
    try {

        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ WEIGHT_ATTRIBUTES_TABLE } 
            WHERE  ${ WEIGHT_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [weightAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing weight attribute entry in the database.
 * Validates the input JSON object, retrieves the correct weight attribute unit ID,
 * executes an SQL UPDATE query to update the specified weight attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentWeightAttributeId - The current ID of the weight attribute to be updated.
 * @param {string} newWeightAttributeId - The new ID for the weight attribute after updating.
 * @param {Object} weightAttributeJSON - The JSON object representing the new values for the weight attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated weight attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateWeightAttribute = async (currentWeightAttributeId, newWeightAttributeId, weightAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateWeightAttributeJSON(weightAttributeJSON)) {

            // Retrieve the correct weight attribute unit id
            const weightAttributeUnitId = await retrieveWeightAttributeUnitID(weightAttributeJSON.weight.unit, connection);

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${WEIGHT_ATTRIBUTES_TABLE} 
                SET
                    ${WEIGHT_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${WEIGHT_ATTRIBUTE_VALUE_COLUMN} = ?,
                    ${WEIGHT_ATTRIBUTE_UNIT_ID_COLUMN} = ?
                WHERE ${WEIGHT_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newWeightAttributeId, weightAttributeJSON.weight.value, weightAttributeUnitId, currentWeightAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveWeightAttribute(newWeightAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Weight Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing weight attribute entry from the database.
 * Executes an SQL DELETE query to remove the weight attribute entry with the specified ID.
 * 
 * @param {string} weightAttributeId - The ID of the weight attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteWeightAttribute = async (weightAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${WEIGHT_ATTRIBUTES_TABLE}
            WHERE ${WEIGHT_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [weightAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new intensity attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * retrieves the correct intensity attribute value ID, and executes an SQL INSERT query.
 * 
 * @param {Object} intensityAttributeJSON - The JSON object representing the intensity attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created intensity attribute entry if successful,
 *                            otherwise returns false.
 */
export const createIntensityAttribute = async (intensityAttributeJSON, connection) => {
    //If the intensityAttributeJSON is valid
    if (validateIntensityAttributeJSON(intensityAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Retrieve the correct intensity attribute unit id
            const intensityAttributeValueId = await retrieveIntensityAttributeValueID(intensityAttributeJSON.intensity.value, connection);

            // Execute SQL statement to create a new intensity_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ INTENSITY_ATTRIBUTES_TABLE } (${ INTENSITY_ATTRIBUTE_ID_COLUMN }, ${ INTENSITY_ATTRIBUTE_VALUE_ID_COLUMN } ) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(intensityAttributeValueId)} );
                `,[uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
    } else {
        console.log("Error: Intensity Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing intensity attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} intensityAttributeId - The ID of the intensity attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved intensity attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveIntensityAttribute = async (intensityAttributeId, connection) => {
    try {

        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ INTENSITY_ATTRIBUTES_TABLE } 
            WHERE  ${ INTENSITY_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [intensityAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing intensity attribute entry in the database.
 * Validates the input JSON object, retrieves the correct intensity attribute value ID,
 * executes an SQL UPDATE query to update the specified intensity attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentIntensityAttributeId - The current ID of the intensity attribute to be updated.
 * @param {string} newIntensityAttributeId - The new ID for the intensity attribute after updating.
 * @param {Object} intensityAttributeJSON - The JSON object representing the new values for the intensity attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated intensity attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateIntensityAttribute = async (currentIntensityAttributeId, newIntensityAttributeId, intensityAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateIntensityAttributeJSON(intensityAttributeJSON)) {

            // Retrieve the correct distance attribute unit id
            const intensityAttributeValueId = await retrieveIntensityAttributeValueID(intensityAttributeJSON.intensity.value, connection);

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${INTENSITY_ATTRIBUTES_TABLE} 
                SET
                    ${INTENSITY_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${INTENSITY_ATTRIBUTE_VALUE_ID_COLUMN} = ?
                WHERE ${INTENSITY_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newIntensityAttributeId, intensityAttributeValueId, currentIntensityAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveIntensityAttribute(newIntensityAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Intensity Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing intensity attribute entry from the database.
 * Executes an SQL DELETE query to remove the intensity attribute entry with the specified ID.
 * 
 * @param {string} intensityAttributeId - The ID of the intensity attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteIntensityAttribute = async (intensityAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${INTENSITY_ATTRIBUTES_TABLE}
            WHERE ${INTENSITY_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [intensityAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}

/**
 * Creates a new level attribute entry in the database.
 * Validates the input JSON object, generates a unique UUID,
 * retrieves the correct level attribute value ID, and executes an SQL INSERT query.
 * 
 * @param {Object} levelAttributeJSON - The JSON object representing the level attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {string|boolean} Returns the UUID of the newly created level attribute entry if successful,
 *                            otherwise returns false.
 */
export const createLevelAttribute = async (levelAttributeJSON, connection) => {
    //If the levelAttributeJSON is valid
    if (validateLevelAttributeJSON(levelAttributeJSON)) {

        try {
            // Generate unique UUID
            let uuid = uuidv4();
            // Prepare statement for storing UUID as binary(16) data type in SQL table
            let unhexUUIDStatement = setupUUIDToBinary16SQLStatement(uuid);

            // Retrieve the correct level attribute unit id
            const levelAttributeValueId = await retrieveLevelAttributeValueID(levelAttributeJSON.level.value, connection);

            // Execute SQL statement to create a new level_attributes row
            const [rows, fields] = await connection.execute(
                `
                INSERT INTO ${ LEVEL_ATTRIBUTES_TABLE } (${ LEVEL_ATTRIBUTE_ID_COLUMN }, ${ LEVEL_ATTRIBUTE_VALUE_ID_COLUMN } ) 
                VALUES ( UNHEX(REPLACE(?, "-", "")), ${(levelAttributeValueId)} );
                `,[uuid]);
            
            return uuid;
        } catch(error) {
            console.log("Error Creating: ", error);
        } finally {

        }
    } else {
        console.log("Error: Level Attribute JSON failed validation.")
        return false;
    }
}

/**
 * Retrieves an existing level attribute entry from the database.
 * Executes an SQL SELECT query to retrieve the row with the specified ID.
 * 
 * @param {string} levelAttributeId - The ID of the level attribute to retrieve.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the retrieved level attribute object
 *                                  if found, or null if no matching entry is found or an error occurs.
 */
export const retrieveLevelAttribute = async (levelAttributeId, connection) => {
    try {

        const [rows, fields] = await connection.execute(
            `
            SELECT *
            FROM ${ LEVEL_ATTRIBUTES_TABLE } 
            WHERE  ${ LEVEL_ATTRIBUTE_ID_COLUMN } = UNHEX(REPLACE(?, "-", ""));
            `,
            [levelAttributeId]);
        
        //Return if any rows were found
        return rows.length > 0 ? rows[0] : null;
    } catch(error) {
        console.log("Error Retrieving: ", error)
        return null;
    } finally {

    }
}

/**
 * Updates an existing level attribute entry in the database.
 * Validates the input JSON object, retrieves the correct level attribute value ID,
 * executes an SQL UPDATE query to update the specified level attribute entry,
 * and retrieves the updated row from the database.
 * 
 * @param {string} currentLevelAttributeId - The current ID of the level attribute to be updated.
 * @param {string} newLevelAttributeId - The new ID for the level attribute after updating.
 * @param {Object} levelAttributeJSON - The JSON object representing the new values for the level attribute.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {Promise<Object|null>} A Promise that resolves to the updated level attribute object
 *                                  if the update operation is successful and affects rows in the database,
 *                                  or null if the update fails due to invalid input or no rows are affected.
 */
export const updateLevelAttribute = async (currentLevelAttributeId, newLevelAttributeId, levelAttributeJSON, connection) => {

    try {
        // Validate the input JSON object
        if (validateLevelAttributeJSON(levelAttributeJSON)) {

            // Retrieve the correct level attribute unit id
            const levelAttributeValueId = await retrieveLevelAttributeValueID(levelAttributeJSON.level.value, connection);

            // Execute the SQL update query
            const [rows, fields] = await connection.execute(
                `
                UPDATE ${LEVEL_ATTRIBUTES_TABLE} 
                SET
                    ${LEVEL_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", "")),
                    ${LEVEL_ATTRIBUTE_VALUE_ID_COLUMN} = ?
                WHERE ${LEVEL_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
                `,
                [newLevelAttributeId, levelAttributeValueId, currentLevelAttributeId]
            );
            
            // Check if the update operation affected any rows
            if (rows.affectedRows > 0) {
                // If affected, retrieve the updated row
                const updatedRow = await retrieveLevelAttribute(newLevelAttributeId, connection);
                return updatedRow;
            } else {
                // If no rows were affected, return null
                return null;
            }
        } else {
            // Log an error message if the input JSON object is invalid
            console.log("Error: Level Attribute JSON failed validation.")
            // Return null to indicate that the update failed due to invalid input
            return null;
        }
    } catch(error) {
        console.log("Error Updating: ", error);
    } finally {

    }
}

/**
 * Deletes an existing level attribute entry from the database.
 * Executes an SQL DELETE query to remove the level attribute entry with the specified ID.
 * 
 * @param {string} levelAttributeId - The ID of the level attribute to be deleted.
 * @param {mysql.Connection} connection - The MySQL database connection.
 * @returns {boolean} Returns true if any rows were affected by the delete operation, otherwise returns false.
 */
export const deleteLevelAttribute = async (levelAttributeId, connection) => {

    try {
        const [result, fields] = await connection.execute(
            `
            DELETE
            FROM ${LEVEL_ATTRIBUTES_TABLE}
            WHERE ${LEVEL_ATTRIBUTE_ID_COLUMN} = UNHEX(REPLACE(?, "-", ""));
            `,
            [levelAttributeId]);
        
        // Return true if any rows were affected by the delete operation
        return result.affectedRows > 0;
    } catch(error) {
        console.log("Error Deleting: ", error);
        return false;
    } finally {

    }
}