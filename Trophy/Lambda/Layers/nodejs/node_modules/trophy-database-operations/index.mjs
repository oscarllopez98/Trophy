import {
    createExercise, updateExercise, retrieveExercise, deleteExercise } from '../trophy-database-operations/ExerciseOperations.mjs'
import { 
    createExerciseAttributeWithJSON, retrieveExerciseAttribute, updateExerciseAttribute, deleteExerciseAttribute,
    createDistanceAttribute, retrieveDistanceAttribute, updateDistanceAttribute, deleteDistanceAttribute,
    createTimeAttribute, retrieveTimeAttribute, updateTimeAttribute, deleteTimeAttribute,
    createSetsAttribute, retrieveSetsAttribute, updateSetsAttribute, deleteSetsAttribute,
    createRepsAttribute, retrieveRepsAttribute, updateRepsAttribute,deleteRepsAttribute,
    createWeightAttribute, retrieveWeightAttribute, updateWeightAttribute, deleteWeightAttribute,
    createIntensityAttribute, retrieveIntensityAttribute, updateIntensityAttribute, deleteIntensityAttribute,
    createLevelAttribute, retrieveLevelAttribute, updateLevelAttribute, deleteLevelAttribute } from './ExerciseAttributeOperations.mjs';
import { 
    retrieveDistanceAttributeUnitID, 
    retrieveWeightAttributeUnitID,
    retrieveIntensityAttributeValueID,
    retrieveLevelAttributeValueID } from '../trophy-database-operations/ExerciseAttributeUnitsOperations.mjs';
import { 
    translateExerciseSQLRowToJSON,
    translateExerciseAttributeSQLRowToJSON,
    translateDistanceAttributeSQLRowToJSON,
    translateTimeAttributeSQLRowToJSON,
    translateSetsAttributeSQLRowToJSON,
    translateRepsAttributeSQLRowToJSON,
    translateWeightAttributeSQLRowToJSON,
    translateIntensityAttributeSQLRowToJSON,
    translateLevelAttributeSQLRowToJSON } from '../trophy-exercise-data-processing/SQLJSONTranslator.mjs';
import { getConnection, closeConnection, mockOpenConnection } from '../trophy-rds-connection/index.mjs';
import { v4 as uuidv4 } from 'uuid';


const exerciseJSON = {
    "exercise": {
        "name": "Test Exercise",
        "type": "cardio",
        "attributes": {
            "distance": {
            "value": 10,
            "unit": "ft"
            },
            "time": {
            "value": 20000
            },
            "sets": {
            "value": 8
            },
            "reps": {
            "value": 1
            },
            "weight": {
            "value": 250,
            "unit": "lb"
            },
            "intensity": {
            "value": "high"
            },
            "level": {
            "value": 9
            }
        },
        "date": "2024-04-20",
        "duration": 1800,
        "notes": "This was a lot"
      }
    }


const newExerciseJSON = {
    "exercise": {
        "name": "My Updated Exercise!",
        "type": "strength",
        "attributes": {
            "time": {
            "value": 200
            },
            "sets": {
            "value": 2
            },
            "reps": {
            "value": 20
            },
            "weight": {
            "value": 10,
            "unit": "kg"
            },
            "intensity": {
            "value": "low"
            },
            "level": {
            "value": 5
            }
        },        
        "date": "2024-04-26",
        "duration": 200,
        "notes": "I did some new stuff!"
        }
    }


const testExercise = async (exerciseJSON, newExerciseJSON) => {
    let connection = null;
    const startTime = performance.now(); // Record the start time

    try {

        // Open MySQL Connection
        const host = "host";
        const user = "user";
        const password = "password";
        const database = "database";
        connection = await mockOpenConnection(host, user, password, database);

        // Execute test for CRUD operations

        //Create
        console.log("\n- - - - - BEGIN: Create Operations Testing - - - - -\n");
        const userId = "1";
        const exerciseName = exerciseJSON.exercise.name;
        const exerciseType = exerciseJSON.exercise.type;
        const exerciseAttributesID = exerciseJSON.exercise.attributes ? await createExerciseAttributeWithJSON(exerciseJSON.exercise.attributes, connection) : null;
        const exerciseNotes = exerciseJSON.exercise.notes;
        const trackExercise = true
        
        const uuid = await createExercise(userId, exerciseName, exerciseType, exerciseAttributesID, exerciseNotes, trackExercise, connection);
  

        // Retrieve
        console.log("\n- - - - - BEGIN: Retrieve Operations Testing - - - - -\n");
        let retrievedExerciseRow = await retrieveExercise(uuid, connection);
        translateExerciseSQLRowToJSON(retrievedExerciseRow);


        // Update
        console.log("- - - - - BEGIN: Update Operations Testing - - - - -");
        const newUserId = "1";
        const newExerciseName = newExerciseJSON.exercise.name;
        const newExerciseDateCreated = newExerciseJSON.exercise.date;
        const newExerciseNotes = newExerciseJSON.exercise.notes;
        const newTrackExercise = true

        let updatedExerciseRow = await updateExercise(uuid, uuid, newExerciseName, newExerciseJSON.exercise, newUserId, newExerciseDateCreated, newExerciseNotes, newTrackExercise, connection);
        translateExerciseSQLRowToJSON(updatedExerciseRow);

        // Delete
        console.log("\n- - - - - BEGIN: Delete Operations Testing - - - - -\n");
        console.log("Cleaning up resources...");
        await deleteExercise(uuid, connection);

    } catch (error) {
        console.error("Error occurred in testExercise:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
}





const exerciseAttributeJSON = {
    userDefined: {
        value: null,
        unit: null
    },
    distance: {
        value: 100.25,
        unit: "km"
    },
    time: {
        value: 6000,
    },
    sets: {
        value: 5,
    },
    reps: {
        value: 10,
    },
    weight: {
        value: 500,
        unit: "lb"
    },
    intensity: {
        value: "low",
    },
    level: {
        value: 9,
    }
}

const newExerciseAttributeJSON = {
    userDefined: {
        value: null,
        unit: null
    },
    distance: null,
    time: {
        value: 10000,
    },
    sets: {
        value: 10,
    },
    reps: {
        value: 4,
    },
    weight: {
        value: 70,
        unit: "kg"
    },
    intensity: {
        value: "high",
    },
    level: {
        value: 1,
    }
}

/**
 * Tests the CRUD operations for exercise attributes.
 * @returns {Promise<void>}
 */
const testExerciseAttributes = async () => {
    let connection = null;
    try {
        // Open MySQL Connection
        const host = "host";
        const user = "user";
        const password = "password";
        const database = "database";
        connection = await mockOpenConnection(host, user, password, database);

        // Execute test for CRUD operations
        await testExerciseAttributeOperations(connection);

    } catch (error) {
        console.error("Error occurred in testExerciseAttributes:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
    }
};

/**
 * Tests the CRUD operations for exercise attributes.
 * @returns {Promise<void>}
 */
const testExerciseAttributeOperations = async (connection) => {
    const startTime = performance.now(); // Record the start time

    try {

        console.log("- - - - - BEGIN: Create Operations Testing - - - - -");

        // Execute all asynchronous functions concurrently
        const [
            createdDistanceAttributeUUID,
            createdTimeAttributeUUID,
            createdSetsAttributeUUID,
            createdRepsAttributeUUID,
            createdWeightAttributeUUID,
            createdIntensityAttributeUUID,
            createdLevelAttributeUUID
        ] = await Promise.all([
            createDistanceAttribute(exerciseAttributeJSON, connection),
            createTimeAttribute(exerciseAttributeJSON, connection),
            createSetsAttribute(exerciseAttributeJSON, connection),
            createRepsAttribute(exerciseAttributeJSON, connection),
            createWeightAttribute(exerciseAttributeJSON, connection),
            createIntensityAttribute(exerciseAttributeJSON, connection),
            createLevelAttribute(exerciseAttributeJSON, connection)
        ]);


        //Create Test
        const createdExerciseAttributeUUID = await createExerciseAttribute({
            distance_attribute_id: createdDistanceAttributeUUID,
            time_attribute_id: createdTimeAttributeUUID,
            sets_attribute_id: createdSetsAttributeUUID,
            reps_attribute_id: createdRepsAttributeUUID,
            weight_attribute_id: createdWeightAttributeUUID,
            intensity_attribute_id: createdIntensityAttributeUUID,
            level_attribute_id: createdLevelAttributeUUID,
        }, connection);


        console.log("- - - - - BEGIN: Retrieve Operations Testing - - - - -");

        //Retrieve Test
        const retrievedExerciseAttributeRow = await retrieveExerciseAttribute(createdExerciseAttributeUUID, connection);
        console.log("Retrieved Exercise Attribute RAW SQL: ", retrievedExerciseAttributeRow);
        const retrievedExerciseAttribute = await translateExerciseAttributeSQLRowToJSON(retrievedExerciseAttributeRow, connection);
        console.log("Retrieved Exercise Attribute JSON Formatted", retrievedExerciseAttribute);


        console.log("- - - - - BEGIN: Update Operations Testing - - - - -");

        // Update Test
        const updatedExerciseAttributeResultRow = await updateExerciseAttribute(createdExerciseAttributeUUID, createdExerciseAttributeUUID, newExerciseAttributeJSON, connection);
        const updatedExerciseAttribute = await translateExerciseAttributeSQLRowToJSON(updatedExerciseAttributeResultRow, connection);
        console.log("Updated Exercise Attribute", updatedExerciseAttribute);


        console.log("- - - - - BEGIN: Delete Operations Testing - - - - -");
        console.log("Cleaning up resources...")
        //Delete Test
        const deletedExerciseAttribute = await deleteExerciseAttribute(createdExerciseAttributeUUID, connection);
        console.log("Deleted Exercise Attribute: ", deletedExerciseAttribute);

    } catch (error) {
        console.error("Error occurred in test testExerciseAttributeOperations():", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
};


const distanceAttributeJSON = { 
    distance: {
        value: 15.25, 
        unit: 'km'
    }
};

const newDistanceAttributeJSON = {
    distance: {
        value: 100, 
        unit: 'mi'
    }
};

/**
 * Tests the CRUD operations for distance attributes and unit ID retrieval.
 * @returns {Promise<void>}
 */
const testDistanceAttributes = async () => {
    let connection = null;
    try {
        // Open MySQL Connection
        connection = await getConnection();

        // Execute test for CRUD operations
        await testDistanceAttributeOperations(connection);

        // Execute test for unit ID retrieval
        await testDistanceAttributeUnitsOperations(connection);
    } catch (error) {
        console.error("Error occurred in testDistanceAttributes:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
    }
};

/**
 * Tests the CRUD operations for distance attributes.
 * @returns {Promise<void>}
 */
const testDistanceAttributeOperations = async (connection) => {
    const startTime = performance.now(); // Record the start time

    try {

        //Create Test
        const createdDistanceAttributeUUID = await createDistanceAttribute(distanceAttributeJSON, connection);

        //Retrieve Test
        const retrievedDistanceAttributeRow = await retrieveDistanceAttribute(createdDistanceAttributeUUID, connection);
        console.log("Retrieved Distance Attribute RAW SQL: ", retrievedDistanceAttributeRow);
        const retrievedDistanceAttribute = await translateDistanceAttributeSQLRowToJSON(retrievedDistanceAttributeRow, connection);
        console.log("Retrieved Distance Attribute JSON Formatted", retrievedDistanceAttribute);

        //Update Test
        const updatedUUID = uuidv4();
        const updatedDistanceAttributeResultRow = await updateDistanceAttribute(createdDistanceAttributeUUID, updatedUUID, newDistanceAttributeJSON, connection);
        const updatedDistanceAttribute = await translateDistanceAttributeSQLRowToJSON(updatedDistanceAttributeResultRow, connection);
        console.log("Updated Distance Attribute", updatedDistanceAttribute);

        //Delete Test
        const deletedDistanceAttribute = await deleteDistanceAttribute(updatedUUID, connection);
        console.log("Deleted Distance Attribute: ", deletedDistanceAttribute);

    } catch (error) {
        console.error("Error occurred in test testDistanceAttributeOperations():", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
};

/**
 * Executes a test operation to retrieve the unit ID of a distance attribute unit.
 * 
 * @returns {Promise<void>} A promise that resolves when the test operation is completed.
 * @throws {Error} If an error occurs during the test operation.
 */
const testDistanceAttributeUnitsOperations = async (connection) => {
    try {

        const retrievedDistanceAttributeUnitID = await retrieveDistanceAttributeUnitID(distanceAttributeJSON.distance.unit, connection)
        console.log("retrievedDistanceAttributeUnitID: ", retrievedDistanceAttributeUnitID);

    } catch(error) {
        console.error("Error occurred in test testDistanceAttributeUnitsOperations() ", error);
    } finally {

    }
}


const timeAttributeJSON = { 
    time: {
        value: 60
    }
};

const newTimeAttributeJSON = { 
    time: {
        value: 7200
    }
};

/**
 * Tests the CRUD operations for time attributes.
 * @returns {Promise<void>}
 */
const testTimeAttributeOperations = async () => {
    const startTime = performance.now(); // Record the start time

    try {

        //Open MySQL Connection
        const connection = await getConnection();

        //Create Test
        const createdTimeAttributeUUID = await createTimeAttribute(timeAttributeJSON, connection);
        console.log("Created UUID: ", createdTimeAttributeUUID);

        //Retrieve Test
        const retrievedTimeAttributeRow = await retrieveTimeAttribute(createdTimeAttributeUUID, connection);
        console.log("Retrieved Time Attribute RAW SQL: ", retrievedTimeAttributeRow);
        const retrievedTimeAttribute = await translateTimeAttributeSQLRowToJSON(retrievedTimeAttributeRow, connection);
        console.log("Retrieved Time Attribute JSON Formatted", retrievedTimeAttribute);

        // //Update Test
        const updatedUUID = uuidv4();
        const updatedTimeAttributeResultRow = await updateTimeAttribute(createdTimeAttributeUUID, updatedUUID, newTimeAttributeJSON, connection);
        const updatedTimeAttribute = await translateTimeAttributeSQLRowToJSON(updatedTimeAttributeResultRow, connection);
        console.log("Updated Time Attribute", updatedTimeAttribute);

        // //Delete Test
        const deletedTimeAttribute = await deleteTimeAttribute(updatedUUID, connection);
        console.log("Deleted Time Attribute: ", deletedTimeAttribute);

    } catch (error) {
        console.error("Error occurred in test testTimeAttributeOperations() ", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);

        //Close MySQL Connection
        await closeConnection();
    }
};


const setsAttributeJSON = { 
    sets: {
        value: 10
    }
};

const newSetsAttributeJSON = { 
    sets: {
        value: 4
    }
};

/**
 * Tests the CRUD operations for sets attributes.
 * @returns {Promise<void>}
 */
const testSetsAttributeOperations = async () => {
    const startTime = performance.now(); // Record the start time

    try {

        //Open MySQL Connection
        const connection = await getConnection();

        //Create Test
        const createdSetsAttributeUUID = await createSetsAttribute(setsAttributeJSON, connection);
        console.log("Created UUID: ", createdSetsAttributeUUID);

        //Retrieve Test
        const retrievedSetsAttributeRow = await retrieveSetsAttribute(createdSetsAttributeUUID, connection);
        console.log("Retrieved Sets Attribute RAW SQL: ", retrievedSetsAttributeRow);
        const retrievedSetsAttribute = await translateSetsAttributeSQLRowToJSON(retrievedSetsAttributeRow, connection);
        console.log("Retrieved Sets Attribute JSON Formatted", retrievedSetsAttribute);

        // //Update Test
        const updatedUUID = uuidv4();
        const updatedSetsAttributeResultRow = await updateSetsAttribute(createdSetsAttributeUUID, updatedUUID, newSetsAttributeJSON, connection);
        const updatedSetsAttribute = await translateSetsAttributeSQLRowToJSON(updatedSetsAttributeResultRow, connection);
        console.log("Updated Sets Attribute", updatedSetsAttribute);

        // //Delete Test
        const deletedSetsAttribute = await deleteSetsAttribute(updatedUUID, connection);
        console.log("Deleted Sets Attribute: ", deletedSetsAttribute);

    } catch (error) {
        console.error("Error occurred in test testSetsAttributeOperations() ", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);

        //Close MySQL Connection
        await closeConnection();
    }
};


const repsAttributeJSON = { 
    reps: {
        value: 6
    }
};

const newRepsAttributeJSON = { 
    reps: {
        value: 20
    }
};

/**
 * Tests the CRUD operations for reps attributes.
 * @returns {Promise<void>}
 */
const testRepsAttributeOperations = async () => {
    const startTime = performance.now(); // Record the start time

    try {

        //Open MySQL Connection
        const connection = await getConnection();

        //Create Test
        const createdRepsAttributeUUID = await createRepsAttribute(repsAttributeJSON, connection);
        console.log("Created UUID: ", createdRepsAttributeUUID);

        //Retrieve Test
        const retrievedRepsAttributeRow = await retrieveRepsAttribute(createdRepsAttributeUUID, connection);
        console.log("Retrieved Reps Attribute RAW SQL: ", retrievedRepsAttributeRow);
        const retrievedRepsAttribute = await translateRepsAttributeSQLRowToJSON(retrievedRepsAttributeRow, connection);
        console.log("Retrieved Reps Attribute JSON Formatted", retrievedRepsAttribute);

        // //Update Test
        const updatedUUID = uuidv4();
        const updatedRepsAttributeResultRow = await updateRepsAttribute(createdRepsAttributeUUID, updatedUUID, newRepsAttributeJSON, connection);
        const updatedRepsAttribute = await translateRepsAttributeSQLRowToJSON(updatedRepsAttributeResultRow, connection);
        console.log("Updated Reps Attribute", updatedRepsAttribute);

        // //Delete Test
        const deletedRepsAttribute = await deleteRepsAttribute(updatedUUID, connection);
        console.log("Deleted Reps Attribute: ", deletedRepsAttribute);

    } catch (error) {
        console.error("Error occurred in test testRepsAttributeOperations() ", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);

        //Close MySQL Connection
        await closeConnection();
    }
};


const weightAttributeJSON = { 
    weight: {
        value: 120.01, 
        unit: 'kg'
    }
};

const newWeightAttributeJSON = {
    weight: {
        value: 50.00, 
        unit: 'lb'
    }
};

/**
 * Tests the CRUD operations for weight attributes and unit ID retrieval.
 * @returns {Promise<void>}
 */
const testWeightAttributes = async () => {
    let connection = null;
    try {
        // Open MySQL Connection
        connection = await getConnection();

        // Execute test for CRUD operations
        await testWeightAttributeOperations(connection);

        // Execute test for unit ID retrieval
        await testWeightAttributeUnitsOperations(connection);
    } catch (error) {
        console.error("Error occurred in testWeightAttributes:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
    }
};

/**
 * Tests the CRUD operations for weight attributes.
 * @returns {Promise<void>}
 */
const testWeightAttributeOperations = async (connection) => {
    const startTime = performance.now(); // Record the start time

    try {

        // Create Test
        const createdWeightAttributeUUID = await createWeightAttribute(weightAttributeJSON, connection);

        // Retrieve Test
        const retrievedWeightAttributeRow = await retrieveWeightAttribute(createdWeightAttributeUUID, connection);
        console.log("Retrieved Weight Attribute RAW SQL: ", retrievedWeightAttributeRow);
        const retrievedWeightAttribute = await translateWeightAttributeSQLRowToJSON(retrievedWeightAttributeRow, connection);
        console.log("Retrieved Weight Attribute JSON Formatted", retrievedWeightAttribute);

        // Update Test
        const updatedUUID = uuidv4();
        const updatedWeightAttributeResultRow = await updateWeightAttribute(createdWeightAttributeUUID, updatedUUID, newWeightAttributeJSON, connection);
        const updatedWeightAttribute = await translateWeightAttributeSQLRowToJSON(updatedWeightAttributeResultRow, connection);
        console.log("Updated Weight Attribute", updatedWeightAttribute);

        // Delete Test
        const deletedWeightAttribute = await deleteWeightAttribute(updatedUUID, connection);
        console.log("Deleted Weight Attribute: ", deletedWeightAttribute);

    } catch (error) {
        console.error("Error occurred in test testWeightAttributeOperations():", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
};

/**
 * Executes a test operation to retrieve the unit ID of a weight attribute unit.
 * 
 * @returns {Promise<void>} A promise that resolves when the test operation is completed.
 * @throws {Error} If an error occurs during the test operation.
 */
const testWeightAttributeUnitsOperations = async (connection) => {
    try {

        const retrievedWeightAttributeUnitID = await retrieveWeightAttributeUnitID(weightAttributeJSON.weight.unit, connection)
        console.log("retrievedWeightAttributeUnitID: ", retrievedWeightAttributeUnitID);

    } catch(error) {
        console.error("Error occurred in test testWeightAttributeUnitsOperations() ", error);
    } finally {

    }
}


const intensityAttributeJSON = { 
    intensity: {
        value: "med"
    }
};

const newIntensityAttributeJSON = { 
    intensity: {
        value: "high"
    }
};

/**
 * Tests the CRUD operations for intensity attributes and value ID retrieval.
 * @returns {Promise<void>}
 */
const testIntensityAttributes = async () => {
    let connection = null;
    try {
        // Open MySQL Connection
        connection = await getConnection();

        // Execute test for CRUD operations
        await testIntensityAttributeOperations(connection);

        // Execute test for value ID retrieval
        await testIntensityAttributeValuesOperations(connection);
    } catch (error) {
        console.error("Error occurred in testIntensityAttributes:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
    }
};

/**
 * Tests the CRUD operations for intensity attributes.
 * @returns {Promise<void>}
 */
const testIntensityAttributeOperations = async (connection) => {
    const startTime = performance.now(); // Record the start time

    try {

        //Create Test
        const createdIntensityAttributeUUID = await createIntensityAttribute(intensityAttributeJSON, connection);

        //Retrieve Test
        const retrievedIntensityAttributeRow = await retrieveIntensityAttribute(createdIntensityAttributeUUID, connection);
        console.log("Retrieved Intensity Attribute RAW SQL: ", retrievedIntensityAttributeRow);
        const retrievedIntensityAttribute = await translateIntensityAttributeSQLRowToJSON(retrievedIntensityAttributeRow, connection);
        console.log("Retrieved Intensity Attribute JSON Formatted", retrievedIntensityAttribute);

        //Update Test
        const updatedUUID = uuidv4();
        const updatedIntensityAttributeResultRow = await updateIntensityAttribute(createdIntensityAttributeUUID, updatedUUID, newIntensityAttributeJSON, connection);
        const updatedIntensityAttribute = await translateIntensityAttributeSQLRowToJSON(updatedIntensityAttributeResultRow, connection);
        console.log("Updated Intensity Attribute", updatedIntensityAttribute);

        //Delete Test
        const deletedIntensityAttribute = await deleteIntensityAttribute(updatedUUID, connection);
        console.log("Deleted Intensity Attribute: ", deletedIntensityAttribute);

    } catch (error) {
        console.error("Error occurred in test testIntensityAttributeOperations():", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
};

/**
 * Executes a test operation to retrieve the value ID of a intensity attribute unit.
 * 
 * @returns {Promise<void>} A promise that resolves when the test operation is completed.
 * @throws {Error} If an error occurs during the test operation.
 */
const testIntensityAttributeValuesOperations = async (connection) => {
    try {

        const retrievedIntensityAttributeValueID = await retrieveIntensityAttributeValueID(intensityAttributeJSON.intensity.value, connection)
        console.log("retrievedIntensityAttributeUnitID: ", retrievedIntensityAttributeValueID);

    } catch(error) {
        console.error("Error occurred in test testIntensityAttributeValuesOperations() ", error);
    } finally {

    }
}


const levelAttributeJSON = { 
    level: {
        value: 9
    }
};

const newLevelAttributeJSON = { 
    level: {
        value: 7
    }
};

/**
 * Tests the CRUD operations for level attributes and value ID retrieval.
 * @returns {Promise<void>}
 */
const testLevelAttributes = async () => {
    let connection = null;
    try {
        // Open MySQL Connection
        connection = await getConnection();

        // Execute test for CRUD operations
        await testLevelAttributeOperations(connection);

        // Execute test for value ID retrieval
        await testLevelAttributeValuesOperations(connection);
    } catch (error) {
        console.error("Error occurred in testLevelAttributes:", error);
    } finally {
        // Close MySQL Connection
        if (connection) {
            try {
                await closeConnection(connection);
                console.log("Connection Closed");
            } catch (err) {
                console.error("Error closing connection:", err);
            }
        }
    }
};

/**
 * Tests the CRUD operations for level attributes.
 * @returns {Promise<void>}
 */
const testLevelAttributeOperations = async (connection) => {
    const startTime = performance.now(); // Record the start time

    try {

        //Create Test
        const createdLevelAttributeUUID = await createLevelAttribute(levelAttributeJSON, connection);

        //Retrieve Test
        const retrievedLevelAttributeRow = await retrieveLevelAttribute(createdLevelAttributeUUID, connection);
        console.log("Retrieved Level Attribute RAW SQL: ", retrievedLevelAttributeRow);
        const retrievedLevelAttribute = await translateLevelAttributeSQLRowToJSON(retrievedLevelAttributeRow, connection);
        console.log("Retrieved Level Attribute JSON Formatted", retrievedLevelAttribute);

        //Update Test
        const updatedUUID = uuidv4();
        const updatedLevelAttributeResultRow = await updateLevelAttribute(createdLevelAttributeUUID, updatedUUID, newLevelAttributeJSON, connection);
        const updatedLevelAttribute = await translateLevelAttributeSQLRowToJSON(updatedLevelAttributeResultRow, connection);
        console.log("Updated Level Attribute", updatedLevelAttribute);

        //Delete Test
        const deletedLevelAttribute = await deleteLevelAttribute(updatedUUID, connection);
        console.log("Deleted Level Attribute: ", deletedLevelAttribute);

    } catch (error) {
        console.error("Error occurred in test testLevelAttributeOperations():", error);
    } finally {
        const endTime = performance.now(); // Record the end time
        const executionTime = endTime - startTime; // Calculate the execution time
        console.log(`Function execution time: ${executionTime} milliseconds`);
    }
};

/**
 * Executes a test operation to retrieve the value ID of a level attribute unit.
 * 
 * @returns {Promise<void>} A promise that resolves when the test operation is completed.
 * @throws {Error} If an error occurs during the test operation.
 */
const testLevelAttributeValuesOperations = async (connection) => {
    try {

        const retrievedLevelAttributeValueID = await retrieveLevelAttributeValueID(levelAttributeJSON.level.value, connection)
        console.log("retrievedLevelAttributeUnitID: ", retrievedLevelAttributeValueID);

    } catch(error) {
        console.error("Error occurred in test testLevelAttributeValuesOperations() ", error);
    } finally {

    }
}


// Invoke the test function
// testDistanceAttributes();
// testTimeAttributeOperations();
// testSetsAttributeOperations();
// testRepsAttributeOperations();
// testWeightAttributes();
// testLevelAttributes();
// testIntensityAttributes();
// testExerciseAttributes();
// testExercise(exerciseJSON, newExerciseJSON);