import mysql from 'mysql2/promise';
import { getSecretValue } from './SecretsManager.mjs';
import { ERROR } from '../trophy-common-utils/Errors.mjs';

let connection = null;
let pool = null;

/**
 * Attempts to open a connection to the Trophy RDS instance.
 * If a connection is not already established, retrieves environment variable values,
 * fetches database credentials from Secrets Manager, and establishes a connection to the RDS instance.
 * @throws {Error} Throws an error if any required environment variable is 
 *                  not found or if Secrets Manager fails to retrieve the secret value.
 * @returns {Promise<mysql.Connection>} Returns a Promise resolving to the MySQL connection object.
 */
export const openConnection = async () => {
    try {
        if (!connection) {
            console.log("Attempting to Open DB connection");

            const host = process.env.DB_HOST;
            const user = process.env.DB_USER;
            const credsSecretId = process.env.DB_CREDENTIALS_SECRET;
            const database = process.env.DB_DATABASE;

            if (!host || !user || !credsSecretId || !database) {
                const errorMessage = `Actual Environment Variable Values:\n 
                    DB_HOST:${host}\n
                    DB_USER:${user}\n
                    DB_CREDENTIALS_SECRET${credsSecretId}\n
                    DB_DATABASE:${database}`;
                throw new Error(`${ERROR.ERROR_ENV_VARIABLE_NOT_FOUND}, ${errorMessage}`);
            }

            const dbCredsSecretString = await getSecretValue(credsSecretId);

            if (!dbCredsSecretString) {
                throw new Error(`${ERROR.ERROR_SECRETS_MANAGER_COULD_NOT_GET_SECRET_VALUE}. Actual Value: ${dbCredsSecretString}`);
            }

            const secretObject = JSON.parse(dbCredsSecretString);
            const dbPassword = secretObject.password;

            if (!dbCredsSecretString || !secretObject || !dbPassword) {
                throw new Error(`${ERROR.ERROR_RDS_CONNECTION_FAILED}.`);
            }

            connection = await mysql.createConnection({
                host: host,
                user: user,
                password: dbPassword,
                database: database,
                connectTimeout: 30000,
            });

            console.log(`Connection to database: ${database} is Open.`);
        }

        return connection;
    } catch (error) {
        console.error('Error in openConnection:', error);
        throw error;
    }
};

/**
 * Attempts to create a connection pool to the Trophy RDS instance.
 * If a pool is not already established, retrieves environment variable values,
 * fetches database credentials from Secrets Manager, and establishes a connection pool to the RDS instance.
 * @throws {Error} Throws an error if any required environment variable is 
 *                  not found or if Secrets Manager fails to retrieve the secret value.
 * @returns {Promise<mysql.Pool>} Returns a Promise resolving to the MySQL connection pool object.
 */
export const openConnectionPool = async () => {
    try {
        if (!pool) {
            console.log("Attempting to Open DB connection pool");

            const host = process.env.DB_HOST;
            const user = process.env.DB_USER;
            const credsSecretId = process.env.DB_CREDENTIALS_SECRET;
            const database = process.env.DB_DATABASE;
            const connectionLimit = process.env.DB_CONNECTION_POOL_LIMIT;
            const connectTimeout = process.env.DB_CONNECTION_TIMEOUT;

            if (!host || !user || !credsSecretId || !database || !connectionLimit) {
                const errorMessage = `Actual Environment Variable Values:\n 
                    DB_HOST:${host}\n
                    DB_USER:${user}\n
                    DB_CREDENTIALS_SECRET:${credsSecretId}\n
                    DB_DATABASE:${database}\n
                    DB_CONNECTION_LIMIT:${connectionLimit}`;
                throw new Error(`${ERROR.ERROR_ENV_VARIABLE_NOT_FOUND}, ${errorMessage}`);
            }

            const dbCredsSecretString = await getSecretValue(credsSecretId);

            if (!dbCredsSecretString) {
                throw new Error(`${ERROR.ERROR_SECRETS_MANAGER_COULD_NOT_GET_SECRET_VALUE}. Actual Value: ${dbCredsSecretString}`);
            }

            const secretObject = JSON.parse(dbCredsSecretString);
            const dbPassword = secretObject.password;

            if (!dbCredsSecretString || !secretObject || !dbPassword) {
                throw new Error(`${ERROR.ERROR_RDS_CONNECTION_FAILED}.`);
            }

            pool = mysql.createPool({
                host: host,
                user: user,
                password: dbPassword,
                database: database,
                waitForConnections: true,
                connectionLimit: connectionLimit,
                queueLimit: 0,
                connectTimeout: connectTimeout,
            });

            pool.on('connection', (connection) => {
                console.log('Connection acquired from pool');
            });

            pool.on('error', (err) => {
                console.error('Error in database connection:', err);
            });

            console.log(`Connection pool to database: ${database} is Open.`);
        }

        return pool;
    } catch (error) {
        console.error('Error in openConnectionPool:', error);
        throw error;
    }
};

/**
 * Closes the connection to the Trophy RDS instance if a connection exists.
 * @returns {Promise<void>} Returns a Promise indicating the closure of the connection.
 */
export const closeConnection = async () => {
    if (connection) {
        try {
            await connection.end();
            console.log('Connection to database is Closed.');
            connection = null;
        } catch (error) {
            console.error('Error closing connection:', error);
            throw error;
        }
    } else {
        console.log('Could not close Connection because Connection is null.');
    }
};

/**
 * Closes the connection pool to the Trophy RDS instance if a pool exists.
 * @returns {Promise<void>} Returns a Promise indicating the closure of the pool.
 */
export const closeConnectionPool = async () => {
    if (pool) {
        try {
            await new Promise((resolve, reject) => {
                pool.end(err => {
                    if (err) {
                        console.error('Error closing connection pool:', err);
                        reject(err);
                    } else {
                        console.log('Connection pool to database is Closed.');
                        pool = null;
                        resolve();
                    }
                });
            });
        } catch (error) {
            console.error('Error closing connection pool:', error);
            throw error;
        }
    } else {
        console.log('Could not close connection pool because pool is null.');
    }
};

/**
 * Returns the connection to the Trophy RDS instance.
 * If a connection does not exist, attempts to open a new connection.
 * @returns {Promise<mysql.Connection>} Returns a Promise resolving to the MySQL connection object.
 */
export const getConnection = async () => {
    if (!connection) {
        return openConnection();
    }
    return connection;
};

/**
 * Returns a connection from the Trophy RDS connection pool.
 * If a pool does not exist, attempts to create a new connection pool.
 * @returns {Promise<mysql.PoolConnection>} Returns a Promise resolving to the MySQL connection object.
 */
export const getConnectionV2 = async () => {
    if (!pool) {
        await openConnectionPool();
    }

    try {
        const getConnectionPromise = () => {
            return pool.getConnection();
        };

        return await getConnectionPromise();
    } catch (error) {
        console.error('Error in getConnectionV2:', error);
        throw error;
    }
};



// Mock connection pool (replace with your actual pool setup)
let mockPool = null;

export const mockGetConnection = async () => {
    try {
        if (mockPool === null) {
            await mockOpenConnectionPool();
        }

        // Wrap getConnection in a Promise to handle it asynchronously
        const getConnectionPromise = () => {
            return mockPool.getConnection();
        };

        // Use await to wait for getConnectionPromise to resolve
        return await getConnectionPromise();
    } catch (error) {
        console.error('Error in getConnection:', error);
        throw error;
    }
};


/**
 * Mock function to close the connection pool to the Trophy RDS connection pool if a pool exists.
 * @returns {Promise<void>} Returns a Promise indicating the closure of the pool.
 */
export const mockCloseConnectionPool = async () => {
    if (mockPool !== null) {
        console.log('Attempting to close connection pool...');
        try {
            await new Promise((resolve, reject) => {
                mockPool.end(err => {
                    if (err) {
                        console.error('Error closing connection pool:', err);
                        reject(err);
                    } else {
                        console.log('Connection pool to database is Closed.');
                        mockPool = null; // Reset pool reference
                        resolve();
                    }
                });
            });
        } catch (error) {
            console.error('Error closing connection pool:', error);
            throw error;
        }
    } else {
        console.log('Could not close connection pool because pool is null.');
    }
};


/**
 * Mock function to open the connection pool to the Trophy RDS connection pool.
 * @returns {Promise<void>} Returns a Promise indicating the completion of the connection pool setup.
 */
export const mockOpenConnectionPool = async () => {
    if (mockPool === null) {
        try {
            console.log("Attempting to Open DB connection pool");

            // Retrieve Environment Variable values
            const host = process.env.TROPHY_DB_HOST;
            const user = process.env.TROPHY_DB_USER;
            const credsSecretId = process.env.TROPHY_DB_CREDENTIALS_SECRET;
            const database = process.env.TROPHY_DB_DATABASE;
            const connectionLimit = process.env.TROPHY_DB_CONNECTION_POOL_LIMIT;
            const connectTimeout = 3000;

            // If any of these are undefined, throw an error because we need these values to connect to the DB
            if (!host || !user || !credsSecretId || !database || !connectionLimit) {
                const errorMessage = `Actual Environment Variable Values:\n 
                    DB_HOST:${host}\n
                    DB_USER:${user}\n
                    DB_CREDENTIALS_SECRET${credsSecretId}\n
                    DB_DATABASE${database}
                    DB_CONNECTION_LIMIT${connectionLimit}`;
                throw new Error(`${ERROR.ERROR_ENV_VARIABLE_NOT_FOUND}, ${errorMessage}`);
            }

            // Get SecretString
            const dbCredsSecretString = await getSecretValue(credsSecretId);

            if (!dbCredsSecretString) {
                throw new Error(`${ERROR.ERROR_SECRETS_MANAGER_COULD_NOT_GET_SECRET_VALUE}. Actual Value: ${dbCredsSecretString}`);
            }

            // Parse the JSON string into a JavaScript object and retrieve password from object
            const secretObject = JSON.parse(dbCredsSecretString);
            const dbPassword = secretObject.password;

            // Verify that none of the values are undefined
            if (!dbCredsSecretString || !secretObject || !dbPassword) {
                throw new Error(`${ERROR.ERROR_RDS_CONNECTION_FAILED}.`);
            }

            // Attempt to create a connection pool
            mockPool = mysql.createPool({
                host: host,
                user: user,
                password: dbPassword,
                database: database,
                waitForConnections: true,
                connectionLimit: connectionLimit, // Adjust based on your requirements
                queueLimit: 0,
                connectTimeout: connectTimeout,
            });

            // Listen for the 'connection' event
            mockPool.on('connection', (connection) => {
                console.log('Connection acquired from pool');
                // You can perform additional operations here if needed
            });

            // Listen for the 'error' event
            mockPool.on('error', (err) => {
                console.error('Error in database connection:', err);
                // Handle connection errors here
            });
            console.log(`Connection pool to database: ${database} is Open.`);

        } catch (error) {
            console.error('Error setting up connection pool:', error);
            throw error; // Propagate error to caller
        }
    }
};