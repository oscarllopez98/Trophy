import mysql from 'mysql2/promise';
import { getSecretValue } from './SecretsManager.mjs';
import { ERROR } from '../trophy-common-utils/Errors.mjs';

var connection = null;

/**
 * Attempts to open a connection to the Trophy RDS instance.
 * If a connection is not already established, retrieves environment variable values,
 * fetches database credentials from Secrets Manager, and establishes a connection to the RDS instance.
 * @throws {Error} Throws an error if any required environment variable is 
 *                  not found or if Secrets Manager fails to retrieve the secret value.
 * @returns {Promise<mysql.Connection>} Returns a Promise resolving to the MySQL connection object.
 */
export const openConnection = async () => {

    if (!connection) {

        console.log("Attempting to Open DB connection");
        
        //Retrieve Environment Variable values
        const host = process.env.DB_HOST;
        const user = process.env.DB_USER;
        const credsSecretId = process.env.DB_CREDENTIALS_SECRET;
        const database = process.env.DB_DATABASE;
        
        //If any of these are undefined, throw an error because we need these values to connect to the DB
        //TODO: Implement failsafe measures to connect to the DB if this fails
        if (!host || !user || !credsSecretId || !database) {
            const errorMessage = `Actual Environment Variable Values:\n 
                DB_HOST:${host}\n
                DB_USER:${user}\n
                DB_CREDENTIALS_SECRET${credsSecretId}\n
                DB_DATABASE${database}`;
            throw new Error(`${ERROR.ERROR_ENV_VARIABLE_NOT_FOUND}, ${errorMessage}`);
        }

        //Get SecretString
        const dbCredsSecretString = await getSecretValue(credsSecretId);

        if (!dbCredsSecretString) {
            throw new Error(`${ERROR.ERROR_SECRETS_MANAGER_COULD_NOT_GET_SECRET_VALUE}. Actual Value: ${dbCredsSecretString}`);
        }

        // Parse the JSON string into a JavaScript object and retrieve password from object
        const secretObject = JSON.parse(dbCredsSecretString);
        const dbPassword = secretObject.password;

        //Verify that non of the values are undefined
        if (!dbCredsSecretString || !secretObject || !dbPassword) {
            throw new Error(`${ERROR.ERROR_RDS_CONNECTION_FAILED}.`);
        }

        //Attempt connection to host with password
        connection = await mysql.createConnection({
            host: host,
            user: user,
            password: dbPassword,
            database: database,
            connectTimeout: 30000,
        });

        console.log(`Connection to database: ${database} is Open.`);
    }

    return connection;
};

// For testing purposes
export const mockOpenConnection = async (host, user, password, database) => {

    if (!connection) {
        connection = await mysql.createConnection({
            host: host,
            user: user,
            password: password,
            database: database ,
            connectTimeout: 30000,
        });
    } 
    
    return connection;
}

/**
 * Closes the connection to the Trophy RDS instance if a connection exists.
 * @returns {Promise<void>} Returns a Promise indicating the closure of the connection.
 */
export const closeConnection = async () => {
    if (connection) {
        await connection.end();
        console.log(`Connection to database is Closed.`);
        connection = null;
    } else {
        console.log(`Could not close Connection to because Connection is null.`);
    }
};

/**
 * Returns the connection to the Trophy RDS instance.
 * If a connection does not exist, attempts to open a new connection.
 * @returns {Promise<mysql.Connection>} Returns a Promise resolving to the MySQL connection object.
 */
export const getConnection = async () => {
    if (!connection) {
        return openConnection();
    }
    return connection;
};